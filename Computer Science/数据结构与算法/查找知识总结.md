

---

### 第一部分：查找的基本概念

**核心指标：平均查找长度 (ASL - Average Search Length)**
这是本章的灵魂，几乎所有计算题都围绕它展开。
*   **公式**：$ASL = \sum P_i \times C_i$
    *   $P_i$：查找第 $i$ 个元素的概率（通常假设等概率，即 $1/n$）。
    *   $C_i$：找到第 $i$ 个元素时需要比较的次数。
*   **区分**：$ASL_{成功}$（查到了）和 $ASL_{失败}$（没查到，通常指查到空指针或确定不存在所需的比较次数）。

---

### 第二部分：线性表的查找

#### 1. 顺序查找 (Sequential Search)
*   **机制**：从头到尾一个一个比。
*   **考点技巧**：**“哨兵” (Sentinel)** 的作用——把查找目标放在数组下标0处，避免每次循环都判断数组越界，提高效率。
*   **复杂度**：$O(n)$。
*   **ASL**：$(n+1)/2$。

#### 2. 折半查找 / 二分查找 (Binary Search) —— **⭐超级高频**
*   **前提**：必须是**有序**的**顺序表**（**链表不行**）。
*   **代码逻辑**：`mid = (low + high) / 2`（向下取整）。
*   **核心考点——判定树 (Decision Tree)**：
    *   折半查找的过程可以用一棵二叉树描述。
    *   树形：除最后一层外，是满二叉树。
    *   **比较次数** = 判定树的层数。
    *   $ASL \approx \log_2(n+1) - 1$。
*   **时间复杂度**：$O(\log_2 n)$。

> **🛑 常见考题自测：**
> 1.  **[计算]** 给定有序表 (8, 11, 19, 23, 27, 33, 45, 55, 67, 98)，若查找元素 19，需比较多少次？若查找元素 40（不存在），需比较多少次？
> 2.  **[画图]** 画出上述序列的二分查找判定树。
> 3.  **[选择]** 有序表有 100 个元素，用折半查找，查找失败时最多比较次数是多少？
>    *   *答案提示：$\lfloor \log_2 n \rfloor + 1$，即 7 次。*

#### 3. 分块查找 (Blocking Search / 索引顺序查找)
*   **特点**：块内无序，块间有序。
*   **机制**：先用二分法查索引表（确定在哪个块），再用顺序法查块内。
*   **考点**：效率介于顺序和折半之间。

---

### 第三部分：树表的查找 (动态查找)

#### 1. 二叉排序树 (BST)
*   **定义**：左子树 < 根 < 右子树。
*   **删除操作（难点）**：
    *   删叶子：直接删。
    *   删只有左/右子树的节点：子承父业。
    *   **删有左右双子的节点**：用**中序遍历的前驱（左子树最大）**或**后继（右子树最小）**来顶替它的位置，然后删除那个替身。
*   **复杂度**：最坏情况（退化成单支树）$O(n)$，最好 $O(\log_2 n)$。

#### 2. 平衡二叉树 (AVL) —— **⭐核心难点**
*   **定义**：**平衡因子**（左右子树高度差绝对值） $|BF| \le 1$。
*   **考点：平衡调整（旋转）**。必须会手画！
    *   **LL型**（在左孩子的左边插入）：右单旋。**冲突的右孩变左孩**
    *   **RR型**（在右孩子的右边插入）：左单旋。**冲突的左孩变右孩子**
    *   **LR型**（在左孩子的右边插入）：先左旋后右旋（双旋）。
    *   **RL型**（在右孩子的左边插入）：先右旋后左旋（双旋）。
*   **最小节点数问题**：深度为 $h$ 的AVL树最少有多少个节点？
    *   公式：$N_h = N_{h-1} + N_{h-2} + 1$ （类似斐波那契数列）。

> **🛑 常见考题自测：**
> 1.  **[作图]** 输入序列 (15, 3, 7, 10, 9, 8)，请一步步画出构建AVL树的过程，并标出每次旋转的类型（如LR旋转）。
> 2.  **[计算]** 高度为 5 的平衡二叉树，至少包含多少个节点？
>    *   *答案提示：N0=0, N1=1, N2=2, N3=4, N4=7, N5=12。*

#### 3. B树 (B-Tree) —— **⭐大题常客**
*   **定义（m阶B树）**：
    *   根节点至少 2 个子树（除非树只有根）。
    *   非根节点至少 $\lceil m/2 \rceil$ 个子树（即至少 $\lceil m/2 \rceil - 1$ 个关键字）。
    *   所有叶子节点在同一层（绝对平衡）。
*   **核心操作**：
    *   **插入（分裂）**：节点满了（关键字数 $> m-1$），中间元素向上提，分裂成两个节点。
    *   **删除（合并/借位）**：节点不够了，向兄弟借；兄弟不够借，合并。
*   **考点**：B树的高度计算、关键字数量范围。

#### 4. B+树
*   **主要区别**（常考选择题）：
    *   B+树所有数据都存储在**叶子节点**（非叶子仅作索引）。
    *   叶子节点之间有指针串联（适合范围查找，如数据库索引）。
    *   m阶B+树节点有 m 个关键字就有 m 棵子树（B树是 m-1 个关键字对应 m 棵子树）。

> **🛑 常见考题自测：**
> 1.  **[作图]** 在一棵 3 阶 B 树中，依次插入 20, 30, 50, 52, 60, 68, 70，画出最终结果。
> 2.  **[选择]** 数据库文件索引通常使用什么数据结构？为什么？（答：B+树，因为磁盘I/O次数少，且支持顺序遍历）。

---

### 第四部分：哈希表 (Hash Tables) —— **⭐计算题重灾区**

#### 1. 散列函数构造
*   **除留余数法**：$H(key) = key \% p$。
    *   **关键**：$p$ 选什么？通常选**不大于表长的最大质数**。

#### 2. 处理冲突的方法
*   **开放定址法 (Open Addressing)**：
    *   **线性探测法**：$+1, +2, +3...$ （容易产生“堆积/聚集”现象）。
    *   **平方探测法 (二次探测)**：$+1^2, -1^2, +2^2, -2^2...$ （避免堆积，但只能探测一半位置）。
*   **拉链法 (Chaining)**：冲突的元素挂在链表后面（无堆积现象）。

#### 3. 核心计算：ASL (成功 vs 失败)
这是最容易丢分的地方。

*   **ASL成功**：$\frac{\sum \text{每个元素被找到的比较次数}}{\text{元素个数}}$
*   **ASL失败**：$\frac{\sum \text{查找每个可能位置失败所需的比较次数}}{p \text{ (模数)}}$
    *   *注意*：这里分母通常是散列函数模数 $p$，而不是表长，也不是元素个数（具体看教材定义，多数考研教材如王道取模数 p）。

> **🛑 常见考题自测 (真题模拟)：**
> **题目**：设散列函数 $H(k) = k \% 13$，表长为 16。现有序列 (19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79)。
> 1.  使用**线性探测法**解决冲突，画出哈希表。
> 2.  计算 $ASL_{成功}$。
> 3.  计算 $ASL_{失败}$。
>
> **检验点**：
> *   你知道线性探测是遇到冲突往后顺延吗？
> *   你知道计算失败ASL时，要从 0 到 12 (即 $0$ 到 $p-1$) 每个入口算一遍“确定为空”需要比几次吗？

---

### 第五部分：必背对比总结表 (考前速记)

| 算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否需要有序 | 备注 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **顺序查找** | $O(n)$ | $O(n)$ | $O(1)$ | 否 | 简单，适合链表 |
| **折半查找** | $O(\log n)$ | $O(\log n)$ | $O(1)$ | **是** | 仅限顺序表 |
| **分块查找** | $O(\log n)$ ~ $O(n)$ | - | $O(n)$ | 块间有序 | 索引表需空间 |
| **BST** | $O(\log n)$ | $O(n)$ | $O(n)$ | 动态生成 | 最坏退化为链表 |
| **AVL** | $O(\log n)$ | $O(\log n)$ | $O(n)$ | 动态生成 | 绝对平衡，插入删麻烦 |
| **哈希表** | **$O(1)$** | $O(n)$ | $O(n)$ | 否 | 空间换时间 |

---

### 复习建议

1.  **先抓死公式**：哈希表的 $ASL$ 计算方法，必须找两道题亲手算一遍，分清分子分母。
2.  **再练画图**：二分查找判定树、AVL 的四种旋转、B 树的分裂与合并。图画对了，分就拿到了 80%。
3.  **最后看代码**：重点看二分查找的边界条件（`while(low <= high)`）和 BST 的插入逻辑。