
---

### 🟢 第一类：插入类排序（核心：将元素插入到已有的有序序列中）

#### 1. **直接插入排序 (Straight Insertion Sort)**
*   **浅显理解**：像打扑克牌一样。每抓一张新牌，就从右往左看，把它插到比它小和比它大的牌中间。
*   **直观过程**（例子：`[5, 2, 4, 1]`）：
    1.  [x] 2, 4, 1（5自成有序）
    2.  拿2，发现比5小，插到5前面 $\to$ **[2, 5]** 4, 1
    3.  拿4，发现比2大但比5小，插中间 $\to$ **[2, 4, 5]** 1
    4.  拿1，最小，插到最前面 $\to$ **[1, 2, 4, 5]**
*   **特性**：稳定；最快 $O(n)$。

#### 2. **希尔排序 (Shell Sort)**
*   **浅显理解**：它是“跳着走”的插入排序。先每隔一段距离（增量）取一组数做插入排序，让序列“基本有序”，最后再全员做一次插入排序。
*   **直观过程**（例子：`[8, 9, 1, 7, 2, 3]`，初始增量3）：
    1.  第一组：8和7比（下标0和3），交换 $\to$ [**7**, 9, 1, **8**, 2, 3]
    2.  第二组：9和2比（下标1和4），交换 $\to$ [7, **2**, 1, 8, **9**, 3]
    3.  第三组：1和3比（下标2和5），不变 $\to$ [7, 2, **1**, 8, 9, **3**]
    4.  最后增量减小，全员微调。
*   **特性**：**不稳定**；效率高于直接插入。

---

### 🔵 第二类：交换类排序（核心：通过两两交换，把最值挪到一端）

#### 3. **冒泡排序 (Bubble Sort)**
*   **浅显理解**：水底的气泡。两个两个比，大的往后走。一趟下来，最大的那个数就会像气泡一样“浮”到最后。
*   **直观过程**（例子：`[4, 3, 2, 1]`）：
    1.  4 vs 3 $\to$ [3, 4, 2, 1]
    2.  4 vs 2 $\to$ [3, 2, 4, 1]
    3.  4 vs 1 $\to$ [3, 2, 1, **4**]（4浮上来了）
    4.  重复上述过程，直到变 [1, 2, 3, 4]。
*   **特性**：稳定；代码最简单。

#### 4. **快速排序 (Quick Sort)**
*   **浅显理解**：设定一个“基准数”（通常是第一个），比它小的站左边，比它大的站右边。然后左右两堆再分别找基准，继续分。
*   **直观过程**（例子：`[4, 6, 2, 5, 3]`，基准是4）：
    1.  第一趟：比4小的放左边，大的放右边 $\to$ **[3, 2]** 4 **[5, 6]**
    2.  对左边 `[3, 2]` 继续：选3为基准 $\to$ **[2]** 3
    3.  最终组合 $\to$ [2, 3, 4, 5, 6]
*   **特性**：**不稳定**；**速度之王（平均最快）**。

---

### 🟡 第三类：选择类排序（核心：每次在剩下的数里挑一个最值出来）

#### 5. **简单选择排序 (Simple Selection Sort)**
*   **浅显理解**：点名出列。在人群里扫视一圈，找出最矮的站在第1位；在剩下的人里再找最矮的，站第2位。
*   **直观过程**（例子：`[3, 4, 1, 2]`）：
    1.  扫一眼发现1最小，1和第一位的3交换 $\to$ **[1]**, 4, 3, 2
    2.  剩下里2最小，2和第二位的4交换 $\to$ **[1, 2]**, 3, 4
*   **特性**：**不稳定**；无论数据如何，时间复杂度都是 $O(n^2)$。

#### 6. **堆排序 (Heap Sort)**
*   **浅显理解**：把数组想象成一棵树。把这棵树调整成“大顶堆”（头最大），然后把头（最大值）摘掉放到最后，再把剩下的调成大顶堆。
*   **直观过程**：
    1.  建堆：把数组变成一个“大的总在上面的”结构。
    2.  交换：把最顶上的大数换到数组末尾。
    3.  调整：把剩下的数重新排成大顶堆。
*   **特性**：**不稳定**；适合在成千上万个数里找前10个最大的。

---

### 🟣 第四类：归并类排序（核心：分而治之，先分小块排好，再合并）

#### 7. **归并排序 (Merge Sort)**
*   **浅显理解**：先拆分再合并。把一个大数组拆成两个，两个拆成四个……直到每个只有1个数（天生有序），然后再两两合并成有序的长串。
*   **直观过程**（例子：`[4, 1, 3, 2]`）：
    1.  拆分：`[4], [1]` 和 `[3], [2]`
    2.  合并：`[1, 4]` 和 `[2, 3]`
    3.  再合并：`[1, 2, 3, 4]`
*   **特性**：**稳定**；需要额外空间（$O(n)$）。

---

### 🔴 第五类：分配类排序（核心：不比大小，按数值的每一位分桶）

#### 8. **基数排序 (Radix Sort)**
*   **浅显理解**：按“个十百位”进桶。准备0-9号十个桶。先按个位数字放进桶里再收起来，再按十位放……
*   **直观过程**（例子：`21, 15, 93, 43`）：
    1.  看个位：21入1号桶，93/43入3号桶，15入5号桶。按顺序收回 $\to$ `21, 93, 43, 15`。
    2.  看十位：15入1号桶，21入2号桶，43入4号桶，93入9号桶。收回 $\to$ `15, 21, 43, 93`（有序了！）。
*   **特性**：稳定；适合位数不多的整数排序。

---

### 💡 重点知识横向总结（考试/面试必背）

| 排序名称 | 英文名 | 相同特性归类 | 稳定性 | 时间复杂度(平均) | 空间复杂度 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **直接插入** | Insertion | 插入类 | 稳定 | $O(n^2)$ | $O(1)$ |
| **希尔排序** | Shell | 插入类 | 不稳定 | $O(n^{1.3})$ | $O(1)$ |
| **冒泡排序** | Bubble | 交换类 | 稳定 | $O(n^2)$ | $O(1)$ |
| **快速排序** | Quick | 交换类 | 不稳定 | $O(n \log n)$ | $O(\log n)$ |
| **简单选择** | Selection | 选择类 | 不稳定 | $O(n^2)$ | $O(1)$ |
| **堆排序** | Heap | 选择类 | 不稳定 | $O(n \log n)$ | $O(1)$ |
| **归并排序** | Merge | 归并类 | 稳定 | $O(n \log n)$ | $O(n)$ |
| **基数排序** | Radix | 分配类 | 稳定 | $O(d(n+r))$ | $O(r)$ |

**快速记忆小技巧**：
1.  **不稳定**的排序：**“快些（希）选堆”**（快速、希尔、简单选择、堆）。
2.  **平均 $O(n \log n)$** 的高手：**“快归堆”**。
3.  **空间复杂度特别**的：归并需要 $O(n)$，快排需要 $O(\log n)$，其余多为 $O(1)$。