这也是数据结构考试中**分值最高、考点最密**的章节之一。排序章节的特点是：**算法流程细节多、性质对比强（时间、空间、稳定性）**。

考试中，排序通常占据两类题型：
1.  **选择题**：秒杀题，考查算法性质（谁稳定？谁空间大？谁在有序时最快？）。
2.  **大题**：手推过程（特别是快排、堆排序）、编写代码（特别是快排、归并）。

以下是排序章节的**核心知识框架与考点自测**。

---

### 第一部分：排序的基本概念

*   **稳定性 (Stability)**：
    *   **定义**：如果关键字 $A = B$，排序前 $A$ 在 $B$ 前面，排序后 $A$ 依然在 $B$ 前面，则稳定；否则不稳定。
    *   **口诀（必背）**：**"快些选堆"不稳定**（快速、希尔、选择、堆）。其他的通常是稳定的。
*   **内部排序 vs 外部排序**：
    *   内部：数据都在内存。
    *   外部：数据量太大，需要在磁盘和内存间倒腾（主要考**归并排序**在外部排序中的应用，如败者树、置换-选择排序，这部分视学校考纲而定，通常较偏）。

---

### 第二部分：插入类排序

#### 1. 直接插入排序 (Direct Insertion Sort)
*   **机制**：打扑克牌理牌。手里是排好的，抓一张新的插到正确位置。
*   **考点**：
    *   **最好情况**：序列本身有序，$O(n)$。
    *   **最坏情况**：逆序，$O(n^2)$。
    *   **哨兵**：`A[0]` 既存待插元素，又防越界。
*   **适用性**：适合**n较小**且**基本有序**的情况。

#### 2. 希尔排序 (Shell Sort)
*   **机制**：缩小增量排序。先按间隔 `d` 分组插排，`d` 逐渐减小到 1。
*   **考点**：
    *   **不稳定**（跳着交换导致相对位置打乱）。
    *   **代码/手推**：给你一个增量序列（如 5, 3, 1），让你写出每一趟后的结果。
    *   最后一个增量必须是 1。

---

### 第三部分：交换类排序（重点）

#### 1. 冒泡排序 (Bubble Sort)
*   **机制**：两两比较，大的后移，每趟确定一个最大值（像泡泡浮上来）。
*   **考点**：
    *   **Flag优化**：如果一趟下来没有发生交换，说明已经有序，直接结束。
    *   比较次数和移动次数与初始状态有关。

#### 2. 快速排序 (Quick Sort) —— **⭐全书最重要的算法**
*   **机制**：分治法。选一个**基准 (Pivot)**（通常是第一个），把比它小的放左边，比它大的放右边，递归执行。
*   **核心考点（必考）**：
    *   **手推 Partition 过程**：给你一个序列，问你第一趟排序后的结果是什么？
        *   *技巧*：基准元素最终会放在它排好序后应该在的位置（枢轴归位）。
    *   **复杂度分析**：
        *   **最好**：每次 pivot 都在中间，$O(n \log n)$。
        *   **最坏**：序列本就有序（正序或逆序），退化成冒泡，$O(n^2)$。
    *   **空间复杂度**：需要递归栈，平均 $O(\log n)$，最坏 $O(n)$。
    *   **特点**：**是所有同数量级($O(n \log n)$)排序中平均性能最好的**。

> **🛑 常见考题自测：**
> 1.  **[手推]** 序列 (46, 79, 56, 38, 40, 84)，以 46 为基准，写出**第一趟**快速排序的结果。
>    *   *答案提示：(40, 38, **46**, 56, 79, 84)。注意 46 的位置。*
> 2.  **[选择]** 快速排序在什么情况下效率最差？（答：有序或基本有序）。

---

### 第四部分：选择类排序

#### 1. 简单选择排序 (Simple Selection Sort)
*   **机制**：每次从后面选个最小的，和前面的交换。
*   **考点**：
    *   **比较次数与初始状态无关**：永远是 $n(n-1)/2$ 次。
    *   **不稳定**（例如 `2, 2*, 1` -> `1, 2*, 2`）。

#### 2. 堆排序 (Heap Sort) —— **⭐大题难点**
*   **前置知识**：完全二叉树、大根堆（根 $\ge$ 左右）、小根堆。
*   **核心步骤**：
    1.  **建堆**（Build Heap）：从最后一个非叶子节点开始，自下而上调整。
    2.  **排序**：输出堆顶，将堆底移到堆顶，执行**向下调整 (Adjust/Sift Down)**。
*   **考点**：
    *   **手画建堆过程**：常考题。必须会画图展示筛选过程。
    *   **时间复杂度**：$O(n \log n)$。
    *   **空间复杂度**：$O(1)$ （注意：这是它比快排、归并强的地方）。
    *   适合 **Top K 问题**（在海量数据中选出前 K 个最大/小）。

> **🛑 常见考题自测：**
> 1.  **[作图]** 输入序列 (50, 10, 90, 30, 70, 40, 80, 60, 20)，请画出建立**大根堆**后的初始堆结构（数组或树形式）。
> 2.  **[选择]** 在排序过程中，哪个算法的**比较次数**与序列初始状态无关？（答：简单选择排序、归并排序）。

---

### 第五部分：归并与基数

#### 1. 归并排序 (Merge Sort)
*   **机制**：分治法。将两个有序表合并成一个有序表（2-way Merge）。
*   **考点**：
    *   **稳定**。
    *   **空间复杂度大**：$O(n)$，需要一个辅助数组。
    *   **时间复杂度**：始终是 $O(n \log n)$，不管你乱不乱。

#### 2. 基数排序 (Radix Sort)
*   **机制**：**不比较**。分配 + 收集。个位排、十位排、百位排...
*   **考点**：
    *   时间复杂度：$O(d(n+r))$，$d$是位数，$r$是基数（如10）。
    *   稳定。

---

### 第六部分：终极对比表（背诵神器）

考试前1小时只看这张表：

| 算法 | 平均时间 | 最坏时间 | 空间复杂度 | 稳定性 | 核心特点 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **直接插入** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **是** | 适合 n 小、基本有序 |
| **希尔** | $O(n^{1.3})$ | $O(n^2)$ | $O(1)$ | 否 | 步长序列关键 |
| **冒泡** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **是** | 可提前结束 |
| **快排** | **$O(n \log n)$** | **$O(n^2)$** | **$O(\log n)$** | 否 | **平均最快**，最坏怕有序 |
| **简单选择** | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 否 | 比较次数恒定 |
| **堆排序** | $O(n \log n)$ | $O(n \log n)$ | **$O(1)$** | 否 | 辅助空间少，适合 Top K |
| **归并** | $O(n \log n)$ | $O(n \log n)$ | **$O(n)$** | **是** | 稳定，但费空间 |
| **基数** | $O(d(n+r))$ | - | $O(r)$ | **是** | 不需比较 |

---

### 第七部分：避坑指南与综合考题

#### 1. 避坑指南
*   **趟数问题**：冒泡和选择排序，第 $i$ 趟结束后，一定有 $i$ 个元素归位（处于最终位置）。但**插入排序不一定**（它只是前 $i$ 个有序）。
*   **比较次数**：堆排序比较次数最少吗？不一定。虽然它数量级低，但常数项可能大。
*   **移动次数**：归并排序移动次数多。简单选择排序移动次数少。

#### 2. 常见综合题（检验你是否融会贯通）

> **题目 1**：若要求尽可能快地对 1000 万个整数进行排序，且内存限制严格（不能用 $O(n)$ 辅助空间），应选什么算法？
> *   **解析**：数据量大 $\rightarrow$ 排除 $O(n^2)$ 算法；内存限制 $O(n)$ $\rightarrow$ 排除归并；要求快 $\rightarrow$ 剩下快排和堆排。通常选**堆排序**（因为快排最坏 $O(n^2)$ 且需要栈空间，堆排最稳且空间 $O(1)$）。但在实际工程中，可能用快排（平均快），这里主要考理论。

> **题目 2**：序列基本有序（如：1, 2, 3, 5, 4, 6），哪种算法最快？
> *   **解析**：**直接插入排序**。此时它接近 $O(n)$。快排反而可能因为选不好基准变慢。

> **题目 3**：找出数组中第 $k$ 小的元素，平均时间复杂度最低的算法思路是？
> *   **解析**：基于**快速排序的 Partition** 思想。每次 Partition 确定一个枢轴位置，如果枢轴下标 $= k$，这就找到了。复杂度 $O(n)$。

### 复习建议
1.  **死磕快排**：代码要会默写，Partition 过程要会画。
2.  **死磕堆排**：建堆的过程（数组下标如何变化）要非常熟练。
3.  **背熟表格**：特别是**稳定性**和**最坏时间复杂度**这两列，选择题最爱出。