# 二叉树链式存储结构
```cpp
struct TreeNode{
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):data(x),left(NULL),right(NULL){}
};

TreeNode* root = new TreeNode(1);//构造一个根节点为1的树
```

# 二叉树的遍历
## 递归遍历（DFS 深度优先搜素）
### 二叉树递归遍历框架
```cpp
void traverse(TreeNode* root){
    if(root == NULL){
      return;
    }
    //前序
    traverse(root -> left);
    //中序->遍历BST结果是有序的
    traverse(root -> right);
    //后序
}
```
## 层序遍历(BFS 广度优先搜素)
### 框架一(只能遍历)
***这种写法最大的优势就是简单。每次把队头元素拿出来，然后把它的左右子节点加入队列，就完事了。但是这种写法的缺点是，无法知道当前节点在第几层。知道节点的层数是个常见的需求，比方说让你收集每一层的节点，或者计算二叉树的最小深度等等。***
```cpp
void traverse(TreeNode* root){
    if(root == NULL){
       return;
    }
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
         TreeNode* cur = q.front();
         q.pop();
         cout << cur -> data << endl;
         if(cur -> left != NULL){
            q.push(cur -> left);
         }
         if(cur -> right != NULL){
            q.push(cur -> right);
         }
    }
}
```
### 框架二(记录深度同时知道当前遍历的层数)
```cpp
void traverse(TreeNode* root){
   if(root == NULL){
     return;
   }
   queue<TreeNode*> q;
   queue.push(root);
   int depth = 1;//记录当前在第一层
   while(!q.empty()){
       int size = q.size();//当前层数节点的数量
       for(int i=0;i < size;i++){
          TreeNode* cur = q.front();
          q.pop();
          cout << "depth = " << depth << "," << cur -> data <<endl;
          if(cur -> left != NULL){
            q.push(cur -> left);
          }
          if(cur -> right != NULL){
            q.push(cur -> right);
          }
       }
       //此时以及遍历完一层中的所有结点，深度增加
       depth++;
   }
}
```

# 主要算法题型

## 二叉树遍历与序列转换
### 已知两种序列，求第三种序列
[二叉树遍历-先序中序求后序遍历序列](二叉树遍历-先序中序求后序遍历序列.pdf)
[二叉排序树的遍历-整数输入与三种遍历](二叉排序树的遍历-整数输入与三种遍历.pdf)
[二叉树不同形态-层次中序遍历求叶子及遍历序列](二叉树不同形态-层次中序遍历求叶子及遍历序列.pdf)
- **核心算法**：递归重建二叉树。
- **常见组合**：
    - 先序 + 中序 -> 后序 / 层次序 / 树结构
        
    - 后序 + 中序 -> 先序 / 层次序 / 树结构
    - 层次序 + 中序 -> 先序 / 后序 / 树结构（难度稍高，需在递归中定位根节点在层次序列中的位置）
        
- **应试关键**：必须记住**中序序列用于划分左右子树**的特性。给定先序（或后序、层次序）的根节点，在中序序列中找到其位置，左侧即为左子树中序，右侧即为右子树中序。
#### 前序 + 中序
![](assets/二叉树算法总结/前序+中序.jpeg)
```cpp
TreeNode* Build(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart, int inEnd){
      if(preStart > preEnd) return NULL;//递归终止条件
      int root_data = preorder[preStart]);
      int index;
      for(int i=0;i < inorder.size();i++){
         if(inorder[i] == root_data){
            index = i;//记录中序遍历中根节点的位置
            break;
         }
      }
      TreeNode* root = new TreeNode(root_data);
      int leftsize = index - inStart;
      //递归构造左右子树
      root -> left = Build(preorder,preStart + 1,preStart + leftsize,inorder,inStart, index - 1);
      root -> right = Build(preorder , preStart + leftsize +1,preEnd,inorder,
      index + 1,inEnd);
      return root;
      
}
```
#### 后序+中序
思路和上面基本一样，找到序列中的根节点和index信息
![](assets/二叉树算法总结/后序+中序.jpeg)
#### 层序+中序
```cpp
TreeNode* BuildTree(const vector<int>& level_order, const vector<int>& in_order){

    TreeNode* root = level_order.empty() ? nullptr : new TreeNode(level_order[0]);

    if(!root) return nullptr;

    vector<int> level_left;

    vector<int> level_right;

    vector<int> in_left;

    vector<int> in_right;

    for(int i=0;i<in_order.size();i++){

        if(in_order[i] == root->val){

            for(int j=0;j<i;j++){

                in_left.push_back(in_order[j]);

            }

            for(int j=i+1;j<in_order.size();j++){

                in_right.push_back(in_order[j]);

            }

        }

    }

    for(int i=1;i<level_order.size();i++){

        for(int j=0;j<in_left.size();j++){

            if(level_order[i] == in_left[j]){

                level_left.push_back(level_order[i]);

            }

        }

        for(int j=0;j<in_right.size();j++){

            if(level_order[i] == in_right[j]){

                level_right.push_back(level_order[i]);

            }

        }

    }

    root->left = BuildTree(level_left, in_left);

    root->right = BuildTree(level_right, in_right);

    return root;

}
```
### 扩展遍历序列建树
[二叉树扩展先序遍历转中序遍历](二叉树扩展先序遍历转中序遍历.pdf)
- **核心算法**：根据带有空节点标记（如 `#`）的**扩展先序遍历字符串**，递归构建二叉树。
- **应试关键**：理解递归过程中如何根据特定字符（如 `#`）判断当前子树为空并回溯。
```cpp
TreeNode* Build(string& preorder) {
    if(preorder.empty()) return NULL;
    
    // Get the first character
    char ch = preorder[0];
    preorder.erase(0, 1);  // Remove the processed character
    
    if(ch == '#') return NULL;
    
    TreeNode* root = new TreeNode(ch);  // Assuming TreeNode stores char data
    
    root->left = Build(preorder);
    root->right = Build(preorder);
    
    return root;
}
```
### 求和树构建
[将满二叉树转换为求和树](将满二叉树转换为求和树.pdf)
```cpp
int subtreeSum(TreeNode* root) {
    if (root == NULL) return 0;
    return root->data + subtreeSum(root->left) + subtreeSum(root->right);
}

// 构建SumTree
int Build_SumTree(TreeNode* root) {
    if (root == NULL) return 0;
    
    // 叶子节点保持不变（或者根据题目要求设为0）
    if (root->left == NULL && root->right == NULL) {
        int old_value = root->data;
        root->data = 0;  // 叶子节点在SumTree中通常为0
        return old_value;
    }
    
    // 先保存原始值
    int old_value = root->data;
    
    // 计算左右子树的和
    int left_sum = Build_SumTree(root->left);
    int right_sum = Build_SumTree(root->right);
    
    // 设置当前节点的值为子树和
    root->data = left_sum + right_sum;
    
    // 返回当前子树的总和（包括原始值）
    return old_value + left_sum + right_sum;
}

```
## 完全二叉树的性质与计算

完全二叉树因其数组存储和编号规律性，成为独立考点。
[完全二叉树的子树-结点数目计算](完全二叉树的子树-结点数目计算.pdf)
[完全二叉树的公共父结点问题](完全二叉树的公共父结点问题.pdf)
[输出完全二叉树的某一层](输出完全二叉树的某一层.pdf)
- **核心算法**：利用完全二叉树“自上而下、自左而右从1开始编号”的性质。
- **应试关键**：记住关键公式：节点 `i` 的左孩子为 `2*i`，右孩子为 `2*i+1`；父节点为 `i/2`（向下取整）。

## 二叉排序树（BST）的操作与判断

这是另一大类重要考点，围绕BST的构建、遍历和性质验证。

1. **BST的构建与遍历**
    - **核心算法**：按照BST规则（左小右大）递归插入节点。
    - **具体题目**：
        - [二叉排序树的遍历-整数输入与三种遍历](二叉排序树的遍历-整数输入与三种遍历.pdf)建立BST并输出前、中、后序遍历。
            ```cpp
           //构造二叉排序树
           void insert(TreeNode* root,int x){
           if(root == NULL){
           root = new TreeNode(x);
           return
           }
           if(x < root->data){
           insert(root->left,x);
           }
           else if(x > root->data){
           insert(root->right,x);
           }
           
           }
            
            ```
        - [二叉排序树之父结点-插入节点求父亲节点值](二叉排序树之父结点-插入节点求父亲节点值.pdf)在插入过程中实时输出父节点值。
        ```cpp
        void insert(TreeNode* &root,int x,int father_data){
	if(root == NULL){
		cout << father_data<<endl;
		root = new TreeNode(x);
		return;
	}
	if(x < root ->data){
		insert(root -> left,x,root -> data);
	}
	else if(x > root->data){
		insert(root -> right,x,root -> data);
	}
	
}
        ```
            
2. **BST的判定**
    
    - **核心算法**：递归检查每个节点是否满足BST定义（左子树所有节点值 < 当前节点值 < 右子树所有节点值）。
    - **具体题目**：[二叉排序树的判定](二叉排序树的判定.pdf)判断给定的二叉树结构是否为有效的BST。
    ```cpp
//定义：该函数返回 root 为根的子树的所有节点是否满足 max->val > root->val > min->val  
bool isBST(TreeNode* root, TreeNode* min, TreeNode* max) { 
// base case 
if (root == nullptr) return true; 
// 若 root->val 不符合 max 和 min 的限制，说明不是合法 BST 
if (min != nullptr && root->val <= min->val) return false; 
if (max != nullptr && root->val >= max->val) return false; 
// 根据定义，限定左子树的最大值是 root->val，右子树的最小值是 root->val 
return isBST(root->left, min, root) && isBST(root->right, root, max); 
}
    ```
        
3. **BST的序列比较**
    - **核心算法**：根据序列构建BST，然后比较两棵BST的结构是否相同（通常通过比较遍历序列或递归比较）。
    - **具体题目**：[相同二叉排序树](相同二叉排序树.pdf)判断两个序列是否能构建出同一棵BST。
    ***判断相同的树**
    ```cpp
    bool isSame(TreeNode* root1,TreeNode* root2){
    if(root1 == NULL&& root2 == NULL) return true;
    if(root1 == NULL||root2 == NULL) return false;
    if(root1->data != root2->data) return false;
    return isSame(root1->left,root2->left)&&isSame(root1->right&&root2->right);
    }
    ```

## 哈夫曼树与WSL计算
[构造哈夫曼树与带权路径长度](构造哈夫曼树与带权路径长度.pdf)
### 1. 核心算法思想：贪心策略 

构造哈夫曼树的核心在于**贪心算法（Greedy Algorithm）**。

其目标是通过权值序列构造一棵带权路径长度（WPL）最短的二叉树 1。为了达到这个目标，我们需要遵循以下逻辑：

- **最小合并**：每次从当前的权值集合中挑出**两个最小**的权值 $a$ 和 $b$ 2。
    
- **生成新根**：将这两个权值合并，创建一个新节点，其权值为 $sum = a + b$。
    
- **迭代循环**：将新生成的权值 $sum$ 放回集合中，重复上述步骤，直到集合中只剩下一个节点（即整棵树的根节点）。
    
- **WPL 计算**：带权路径长度等于所有**非叶子节点**（即所有合并产生的新节点）的权值之和 3333。
    

---

### 2. 优先队列 (Priority Queue) API 总结 🛠️

在 C++ 中，`std::priority_queue` 是实现哈夫曼树最理想的工具，因为它能自动帮我们维护数据的顺序。头文件```#include <queue>```

#### 常用操作方法：

|**方法**|**功能**|**时间复杂度**|
|---|---|---|
|**`push(val)`**|将元素加入队列，自动调整位置|$O(\log n)$|
|**`top()`**|返回优先级最高的元素（堆顶）|$O(1)$|
|**`pop()`**|移除优先级最高的元素|$O(\log n)$|
|**`size()`**|返回队列中元素的个数|$O(1)$|
|**`empty()`**|判断队列是否为空|$O(1)$|

#### 关键的声明方式：

由于我们要找的是**最小值**，必须使用**小顶堆**的声明格式：

```cpp
// 存储 int，底层容器用 vector，比较方式用 greater（小的先出）
priority_queue<int, vector<int>, greater<int>> pq;
//默认大顶堆(大的先出)
priority_queue<int> pq
```


