# 快速排序
## 快速排序的基本思路
1、在 `nums` 数组中任意选择一个元素作为切分元素 `pivot`（一般选择第一个元素）。

```
 [4, 1, 7, 2, 8, 5, 3, 6, 9]
  ^
pivot
```
2、对数组中的元素进行若干交换操作，将小于 `pivot` 的元素放到 `pivot` 的左边，大于 `pivot` 的元素放到 `pivot` 的右边（**换句话说，其实就是将 `pivot` 这一个元素排好序**）。
```
 [3, 1, 2, 4, 8, 5, 7, 6, 9]
           ^
         pivot
```
3、递归地对 `pivot` 左边的数组和右边的数组重复上述步骤：寻找新的切分元素，然后交换元素，使得切分元素左侧都元素都比它小，右侧都元素都比它大（**换句话说，其实就是递归的去把 `pivot` 左右两侧的其他元素排好序**）。
```
 [3, 1, 2] [4] [8, 5, 7, 6, 9]
  ^         ^   ^
pivot1          pivot2

 [1, 2, 3] [4] [5, 7, 6, 8, 9]
        ^   ^            ^
    pivot1             pivot2
```
4、递归地重复上述操作，直到所有元素都放到正确的位置：

```
 [1] [2] [3] [4] [5] [6] [7] [8] [9]
```

所以我说快速排序的思路是：**先把一个元素排好序，然后去把剩下的元素排好序**
## 代码
**挖坑法**
```cpp
#include <iostream> 
#include <vector> 
using namespace std; 
// 使用教材经典的“挖坑法”划分逻辑 
int partition(vector<int>& arr, int low, int high) { 
int pivot = arr[low]; // 以第一个元素为枢轴 
while (low < high) { // 从右向左移动，找第一个比枢轴小的元素 
     while (low < high && arr[high] >= pivot) { high--; } 
     arr[low] = arr[high]; // 将小的移到左边“坑”里 
     // 从左向右移动，找第一个比枢轴大的元素 
     while (low < high && arr[low] <= pivot) { low++; } 
     arr[high] = arr[low]; // 将大的移到右边“坑”里 
     } 
     arr[low] = pivot; // 枢轴放回最终位置 
     return low; 
}
```
**双指针法**
```cpp
#include <vector> 
#include <algorithm> 
using namespace std; 
// 分区函数：返回基准归位后的下标 
int partition(vector<int>& arr, int low, int high) { 
   int pivot = arr[low]; // 选取第一个元素作为基准 
   int i = low + 1; 
   int j = high; 
   while (true) { 
// 从左向右找第一个大于 pivot 的元素 
        while (i <= j && arr[i] <= pivot) i++; 
// 从右向左找第一个小于 pivot 的元素 
        while (i <= j && arr[j] >= pivot) j--; 
        if (i >= j) break; // 哨兵相遇，结束循环 
        swap(arr[i], arr[j]); // 交换 
    } 
// 将基准元素放到最终正确的位置 j 
        swap(arr[low], arr[j]); 
        return j; 
} 
```
**递归排序**
```cpp
void quickSort(vector<int>& arr, int low, int high) { 
    if (low < high) { 
    // 核心步骤：分区 
    int pivotIndex = partition(arr, low, high); 
    // 递归排序左半部分和右半部分 
    quickSort(arr, low, pivotIndex - 1); 
    quickSort(arr, pivotIndex + 1, high); 
    } 
}
```

# 堆排序
### 堆排序的两个关键步骤
1、原地建堆（Heapify）：直接把待排序数组原地变成一个二叉堆。
2、排序（Sort）：将元素不断地从堆中取出，最终得到有序的结果。

## 代码
**二叉堆操作**
```cpp
// 小顶堆的上浮操作，时间复杂度是树高 O(logN)
void minHeapSwim(std::vector<int>& heap, int node) {
    while (node > 0 && heap[parent(node)] > heap[node]) {
        swap(heap, parent(node), node);
        node = parent(node);
    }
}

// 小顶堆的下沉操作，时间复杂度是树高 O(logN)
void minHeapSink(std::vector<int>& heap, int node, int size) {
    while (left(node) < size || right(node) < size) {
        // 比较自己和左右子节点，看看谁最小
        int min = node;
        if (left(node) < size && heap[left(node)] < heap[min]) {
            min = left(node);
        }
        if (right(node) < size && heap[right(node)] < heap[min]) {
            min = right(node);
        }
        if (min == node) {
            break;
        }
        // 如果左右子节点中有比自己小的，就交换
        swap(heap, node, min);
        node = min;
    }
}

// 大顶堆的上浮操作
void maxHeapSwim(std::vector<int>& heap, int node) {
    while (node > 0 && heap[parent(node)] < heap[node]) {
        swap(heap, parent(node), node);
        node = parent(node);
    }
}

// 大顶堆的下沉操作
void maxHeapSink(std::vector<int>& heap, int node, int size) {
    while (left(node) < size || right(node) < size) {
        // 小顶堆和大顶堆的唯一区别就在这里，比较逻辑相反
        // 比较自己和左右子节点，看看谁最大
        int max = node;
        if (left(node) < size && heap[left(node)] > heap[max]) {
            max = left(node);
        }
        if (right(node) < size && heap[right(node)] > heap[max]) {
            max = right(node);
        }
        if (max == node) {
            break;
        }
        swap(heap, node, max);
        node = max;
    }
}

// 父节点的索引
int parent(int node) {
    return (node - 1) / 2;
}

// 左子节点的索引
int left(int node) {
    return node * 2 + 1;
}

// 右子节点的索引
int right(int node) {
    return node * 2 + 2;
}

// 交换数组中两个元素的位置
void swap(std::vector<int>& heap, int i, int j) {
    int temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
}

// 将输入的数组元素从小到大排序
void sort(std::vector<int>& nums) {
    // 第一步，原地建堆，注意这里创建的是大顶堆
    // 只要从左往右对每个元素调用 swim 方法，就可以原地建堆
    for (int i = 0; i < nums.size(); i++) {
        maxHeapSwim(nums, i);
    }

    // 第二步，排序
    // 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可
    int heapSize = nums.size();
    while (heapSize > 0) {
        // 从堆顶删除元素，放到堆的后面
        swap(nums, 0, heapSize - 1);
        heapSize--;
        // 恢复堆的性质
        maxHeapSink(nums, 0, heapSize);
        // 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素
    }
}
```
**排序**
```cpp
// 将输入的数组元素从小到大排序
void sort(int[] nums) {
    // 第一步，原地建堆，注意这里创建的是大顶堆
    // 只要从左往右对每个元素调用 swim 方法，就可以原地建堆
    for (int i = 0; i < nums.length; i++) {
        maxHeapSwim(nums, i);
    }

    // 第二步，排序
    // 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可
    int heapSize = nums.length;
    while (heapSize > 0) {
        // 从堆顶删除元素，放到堆的后面
        swap(nums, 0, heapSize - 1);    
        heapSize--;
        // 恢复堆的性质
        maxHeapSink(nums, 0, heapSize);
        // 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素
    }
}

// maxHeapSink, maxHeapSwim 等函数代码见上文
```

# 归并排序
## 核心思路
把数组切成两半，先把这两半子数组分别排好序，然后再合并这两个有序数组，整个数组就排好序了。
![](assets/排序算法总结/归并排序.jpeg)
## 代码
```cpp
#include <iostream>
#include <vector>

using namespace std;

/**
 * 核心函数 1：合并 (Merge)
 * 功能：将两个已经排好序的子序列 [left, mid] 和 [mid+1, right] 合并成一个有序序列
 */
void merge(int arr[], int left, int mid, int right) {
    // 1. 计算两个子序列的长度
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // 2. 创建临时数组暂存数据（归并排序需要 O(n) 的额外空间）
    vector<int> L(n1), R(n2);

    // 3. 将原数组中的数据拷贝到临时数组 L 和 R 中
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // 4. 比较合并：像拉链一样，按大小顺序从 L 和 R 中取数放回 arr
    int i = 0;    // 临时数组 L 的索引
    int j = 0;    // 临时数组 R 的索引
    int k = left; // 原数组 arr 的起始位置

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) { // 如果左边小，取左边（<= 保证了稳定性）
            arr[k] = L[i];
            i++;
        } else {            // 如果右边小，取右边
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 5. 补齐：如果 L 或 R 还有剩余元素，直接追加到后面
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

/**
 * 核心函数 2：递归拆分 (MergeSort)
 * 功能：通过递归不断将数组平分，直到子数组长度为 1
 */
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // 1. 找到中间位置，防止溢出的写法
        int mid = left + (right - left) / 2;

        // 2. 递归排序左半部分 [left, mid]
        mergeSort(arr, left, mid);

        // 3. 递归排序右半部分 [mid+1, right]
        mergeSort(arr, mid + 1, right);

        // 4. 合并两个有序部分（此时左右两边都已经分别有序）
        merge(arr, left, mid, right);
    }
}

// --- 测试代码 ---
int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "排序前: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    mergeSort(arr, 0, n - 1);

    cout << "排序后: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    cout << endl;

    return 0;
}
```