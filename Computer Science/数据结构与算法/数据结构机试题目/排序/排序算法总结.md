# 快速排序
***挖坑法**
```cpp
#include <iostream> 
#include <vector> 
using namespace std; 
// 使用教材经典的“挖坑法”划分逻辑 
int partition(vector<int>& arr, int low, int high) { 
int pivot = arr[low]; // 以第一个元素为枢轴 
while (low < high) { // 从右向左移动，找第一个比枢轴小的元素 
     while (low < high && arr[high] >= pivot) { high--; } 
     arr[low] = arr[high]; // 将小的移到左边“坑”里 
     // 从左向右移动，找第一个比枢轴大的元素 
     while (low < high && arr[low] <= pivot) { low++; } 
     arr[high] = arr[low]; // 将大的移到右边“坑”里 
     } 
     arr[low] = pivot; // 枢轴放回最终位置 
     return low; 
}
```
**双指针法**
```cpp
#include <vector> 
#include <algorithm> 
using namespace std; 
// 分区函数：返回基准归位后的下标 
int partition(vector<int>& arr, int low, int high) { 
   int pivot = arr[low]; // 选取第一个元素作为基准 
   int i = low + 1; 
   int j = high; 
   while (true) { 
// 从左向右找第一个大于 pivot 的元素 
        while (i <= j && arr[i] <= pivot) i++; 
// 从右向左找第一个小于 pivot 的元素 
        while (i <= j && arr[j] >= pivot) j--; 
        if (i >= j) break; // 哨兵相遇，结束循环 
        swap(arr[i], arr[j]); // 交换 
    } 
// 将基准元素放到最终正确的位置 j 
        swap(arr[low], arr[j]); 
        return j; 
} 
```
**递归排序**
```cpp
void quickSort(vector<int>& arr, int low, int high) { 
    if (low < high) { 
    // 核心步骤：分区 
    int pivotIndex = partition(arr, low, high); 
    // 递归排序左半部分和右半部分 
    quickSort(arr, low, pivotIndex - 1); 
    quickSort(arr, pivotIndex + 1, high); 
    } 
}
```