# 链表增删改查的实现
## 单链表
```cpp
struct ListNode{
   int data;
   ListNode* next;
   ListNode(int x): data(x),next(NULL){}
};


//将数组转化为单链表
ListNode* create(vector<int>& arr){
if(!arr.empty()){
   return NULL;
}
ListNode* head = new ListNode(arr[0]);
ListNode* cur = head;
for(int i=1;i<arr.size();i++){
   cur -> next = new ListNode(arr[i]);
   cur = cur -> next;
}
return head;
}

//遍历单链表(查与改)
for(ListNode* p =head;p != NULL;p = p->next){
   cout << p-> data << endl;
}

//在表尾增加元素
void AddEnd(ListNode*head,int x){
    ListNode* p = head;
    while(p->next!=NULL){
      p = p->next;
    }
    p->next =new ListNode(x);
    return
}

//在表中增加元素(容易错误，注意点1：位置索引（找到前驱节点) 注意点2：不要丢失p->next)
void AddMid(ListNode*head,int index,int x){
   ListNode*p = head;
   //在第index个元素添加新节点，要先找到原本在index处的元素的前驱节点
   for(int i=0;i<index-1;i++){
      p = p -> next;
   }
   ListNode* newNode = new ListNode(x);
   newNode -> next = p ->next;
   p -> next = newNode;
   
}

//删除表中元素
void DeletMid(ListNode* head,int index){
   ListNode* p = head;
   //找到要删除索引的前驱节点
   for(int i =0;i < index-1;i++){
    p = p ->next;
   }
   p -> next = p->next->next;
}


//删除表尾元素，核心找到倒数第二个节点
void DeletEnd(ListNode* head){
    ListNode* p =head;
    //找到末尾元素的前驱节点
    while(p->next->next!=NULL){
      p = p->next;
    }
    p -> next =NULL;
}

//删除表头元素
void DeletFirst(ListNode* &head){
    head = head ->next
}
```

## 双向链表
```cpp
struct ListNode{
    int data;
    ListNode* pre;
    ListNode* next;
    ListNode(int x): data(x),pre(NULL),next(NULL){}
};

//创建双向链表
ListNode* create(vector<int>& arr){
    if(arr.empty()){
       return NULL;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* cur = head;
    for(int i=1;i < arr.size();i++){
       ListNode* newNode = new ListNode(arr[i]);
       cur - next = newNode;
       newNode -> pre = cur;
       cur = cur -> next;
    }
    return head;
}
```

# 线性表的重要算法实现

- **链表操作与去重**
    
    - **算法核心**：遍历链表，使用辅助数据结构（如数组、集合）记录已出现过的键值（或其绝对值），根据规则（如保留首次出现的结点）进行结点的删除或保留。
    - **关键点**：正确处理结点的链接关系（`Next`指针），处理非连续存储的地址信息，以及输出格式。
    - **对应文档**：[链表去重](链表去重.pdf)
    - 
- **有序表合并与去重**
    
    - **算法核心**：**归并思想**。由于两个线性表（L1, L2）本身有序且内部无重复，可以设置两个指针分别遍历两个表，比较当前元素，将较小的、且未在结果表中出现过的元素加入结果表，实现合并后依然有序且无重复。
    - **关键点**：双指针遍历，处理相等元素（去重），以及结果序列的构建。
    - **对应文档**[有序表的合并去重](有序表的合并去重.pdf)
    ```cpp
    ListNode* mergeWithDummy(ListNode* head1, ListNode* head2){
    ListNode dummy(0);  // 哨兵节点
    ListNode* tail = &dummy;
    
    while(head1 && head2){
        if(head1->data < head2->data){
            tail->next = head1;
            head1 = head1->next;
        }
        else if(head1->data == head2->data){
            tail->next = head1;
            head1 = head1->next;
            head2 = head2->next;  // 去重
        }
        else{
            tail->next = head2;
            head2 = head2->next;
        }
        tail = tail->next;
    }
    
    tail->next = head1 ? head1 : head2;
    return dummy.next;
}
    ```
- **约瑟夫环问题**
    
    - **算法核心**：**循环链表模拟**。按照题目描述的报数规则（报数到`m`出列，并用出列者的密码更新`m`），在循环链表中依次删除（出列）结点，并记录出列顺序。
        
    - **关键点**：循环链表的构建、遍历和结点删除，动态更新报数上限`m`。
    - **对应文档**：《约瑟夫环-报数出圈问题.pdf》
- **序列位置重组**
    
    - **算法核心**：**按奇偶下标分离与合并**。遍历原序列，根据结点位置（奇数位或偶数位）将元素分别存入两个辅助列表，最后将两个列表合并输出。
    - **关键点**：下标（索引）的判断（通常从1开始计数），两个子序列的构建。
    - **对应文档**：《奇偶序列-整数序列奇数偶数位置重组.pdf》