# 主要算法
## 1 KMP字符串匹配
实现 KMP 算法通常分为两个部分：

1. **预处理**：计算 `next` 数组（地图）。
    
2. **匹配**：利用 `next` 数组在主串中寻找模式串。
### next数组求值
求 `next` 数组的过程本质上是**模式串自己对自己进行匹配**。我们用两个指针：`i`（当前处理的位置）和 `j`（当前相等前后缀的长度）。
把next数组理解为要如果匹配失败要回退到的位置的指针数组

```cpp
void getNext(string T, int next[]) {
    //初始化
    int m = T.length(); 
    next[0] = 0; // 第一个字符的前后缀长度显然为0
    int j = 0;   // j 代表当前最长相等前后缀的长度
    
    for (int i = 1; i < m; i++) {
        //过程中i指向后缀末尾位置，j指向前缀末尾位置
        // 当匹配失败时，j 顺着 next 数组回溯，直到找到匹配或回到开头
        while (j > 0 && T[i] != T[j]) {
            j = next[j - 1];//不匹配，j回退到前一位的next数组
        }
        // 如果匹配成功，最长相等前后缀长度加1
        if (T[i] == T[j]) {
            j++;
        }
        next[i] = j; // 记录当前位置的长度
    }
}
```
### KMP 匹配过程
有了 `next` 数组，匹配主串 `S` 和模式串 `T` 的逻辑就非常清晰了：主串指针 `i` 永远不回头。
```cpp
void KMP(string S, string T) {
    int n = S.length();
    int m = T.length();
    int next[m];
    getNext(T, next); // 先获取跳跃表
    
    int j = 0; // 模式串的指针
    for (int i = 0; i < n; i++) {
        // 如果失配，模式串指针 j 根据 next 数组跳跃
        while (j > 0 && S[i] != T[j]) {
            j = next[j - 1];
        }
        // 匹配成功
        if (S[i] == T[j]) {
            j++;
        }
        // 找到完整模式串
        if (j == m) {
            cout << "模式串出现在索引: " << i - m + 1 << endl;
            j = next[j - 1]; // 继续找下一个可能的匹配
        }
    }
}
```
### 代码中的关键点 💡

- **`while (j > 0 && T[i] != T[j])`**：这是最精妙的一行。它通过 `next` 数组让指针 `j` 实现“瞬移”，避免了 BF 算法那种从头开始的低效。
    
- **空间复杂度**：由于需要额外存储 `next` 数组，空间复杂度为 $O(m)$。
    
- **时间复杂度**：虽然代码里有嵌套循环，但由于主串指针 `i` 始终递增，总时间复杂度是 $O(n + m)$

# 2 最小周期串
## 判断方法

假设长度为 `n`，我们枚举所有可能的周期长度 `k`（从 1 到 n）：
- `k` 必须整除 `n`
- 验证：原字符串是否等于前 `k` 个字符重复 `n/k` 次
一旦找到最小的满足条件的 `k`，就是答案。
```cpp
#include <iostream>
#include <string>

using namespace std;

int main(){
	string s;
	getline(cin,s);
	int n= s.length();
	int result = n;
	for(int k=1;k<=n;k++){
		if(n%k!=0) continue;//k不是n的因数
		bool isPeriod = true;
		for(int i=k;i<n;i++){
			
			if(s[i]!=s[i%k]){
				isPeriod = false;
				break;
			}
		} 
		if(isPeriod){
			result = k;
			break;
		}
	}
	cout << result << endl;
	return 0;
}
```

