# 二分查找
二分查找（Binary Search）是一种在**有序数组**中查找特定元素的高效算法。它的核心思想是“折半”，通过不断缩小搜索范围，将时间复杂度降低到 $O(\log n)$。

## 1. 核心思想：区间缩减 🎯

想象你在查一本英汉词典。如果你要找字母 "M" 开头的单词，你不会从第一页开始翻，而是先从中间翻开。如果翻到了 "P"，你知道 "M" 肯定在左边那一半，于是你直接排除掉右半部分。
在代码中，我们使用两个“指针”来表示这个搜索范围：
- `left`：区间的起始位置。
- `right`：区间的结束位置。
```cpp
#include <vector>

int binarySearch(std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // [left, right]

    while (left <= right) {
        // 计算中间索引，防止整数溢出
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid; // 找到了！
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标在右侧，忽略左半部分
        } else {
            right = mid - 1; // 目标在左侧，忽略右半部分
        }
    }

    return -1; // 没找到
}
```
## 2.两个最容易出错的地方：

- **循环条件 `left <= right`**： 因为我们的初始范围是 `[0, nums.size() - 1]`，这是一个包含两端点的闭区间。当 `left == right` 时，区间内还有一个元素没检查，所以必须包含=。
- **计算中间值 `mid`**： 你可能会看到有人写 `mid = (left + right) / 2`。但在处理极大数值时，`left + right` 可能会超过 `int` 的最大范围导致溢出。使用 `left + (right - left) / 2` 在数学上是等价的，但更加安全。

## 3.边界问题
**如果数组中有重复的数字，我们要找“第一个”出现的 8 的位置**
**（例如 `nums = {2, 8, 8, 8, 10}`）**
如果数组里有多个相同的目标值，而我们要找的是**第一个**（最左边的一个），那么当 `nums[mid] == target` 时，我们不能立即返回，因为左边可能还有同样的数字。
此时，我们需要收缩**右边界**，也就是让 `right = mid - 1`，继续在左半部分探测，直到区间缩减到不能再缩为止。
```cpp
int findFirst(std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int ans = -1; // 用来记录目前找到的符合条件的索引

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ans = mid;        // 暂时记录下这个位置
            right = mid - 1;  // 重点：继续向左边找，看有没有更早出现的
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}
```
**如果改为最后一次出现，就缩短左边界**





