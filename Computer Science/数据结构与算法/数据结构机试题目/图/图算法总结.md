# 图的存储
![](assets/图算法总结/2.jpeg)
```cpp
// 邻接表
// graph[x] 存储 x 的所有邻居节点以及对应的权重
struct Edge {
    int to;
    int weight;
};
vector<vector<Edge>> graph;//graph[from][0] == Edge{to,weight}

// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
vector<vector<int>> matrix;
```
## 有向图
### 邻接表
```cpp
struct Edge{
    int to;
    int weight;//无权时weight为1
    Edge(int to,int weight):to(to),weight(weight){}
};
// 邻接表，graph[v] 存储节点 v 的所有邻居节点及对应权重
vector<vector<Edge>> graph;
```
### 邻接矩阵
```cpp
// 邻接矩阵，matrix[from][to] 存储从节点 from 到节点 to 的边的权重 
// 0 表示没有连接 
vector<vector<int>> matrix;//无权时数值改为01，或者使用bool
```
## 无向图
**无向加权图就等同于双向的有向加权图，加边的时候记得双向都要加**

## 操作方法
```cpp
class Graph {
public:
    // 添加一条边（带权重）
    void addEdge(int from, int to, int weight){
       //邻接表
       graph[from].push_back(Edge(to,weight));
       graph[to].push_back(Edge(from,weight));//无向图
       //邻接矩阵
       graph[from][to] = weight;
       graph[to][from] = weight;//无向图
    }

    // 删除一条边
    void removeEdge(int from, int to){
        //邻接表
        //遍历找到要删除的边
        //如果是无向图，在调用函数时还要删除to到from的边
        for(auto& it = graph[from].begin();it != graph[from].end;it++){
            if(it -> to == to){
               graph[from].erase(it);
               break;
            } 
        }
        //邻接矩阵
        //直接删除
        graph[from][to] == 0;
        graph[from][to] == 0;//无向图
    }

    // 判断两个节点是否相邻
    bool hasEdge(int from, int to){
        //邻接表
        for(auto& it = graph[from].begin();it!= graph[from].end();it++){
           if(it->to == to){
               return true;
           }
        }
        return false;
        //邻接矩阵
        return graph[from][to];
    }

    // 返回一条边的权重
    int weight(int from, int to){
    //邻接表
    for(auto& it = graph[from].begin();it!= graph[from].end();it++){
        if(it-> to == to){
           return it->weight;
        }
    }
    else return 0;//无边则返回0或者无穷大
    //邻接矩阵
    return graph[from][to];
    }

    // 返回某个节点的所有邻居节点和对应权重
    vector<Edge> neighbors(int v){

       return graph[v];

    }

    // 返回节点总数
    virtual int size() = 0;

    // 虚拟析构函数，确保子类正确释放资源
    virtual ~Graph() {}
};
```

# 主要算法
## 1 遍历
### 广度优先搜索（BFS）
[图的广度优先遍历-无向图邻接矩阵遍历](图的广度优先遍历-无向图邻接矩阵遍历.pdf)
它的核心工具是一个**队列 (Queue)** 和一个标记访问过的**数组 (Visited)**。
#### BFS 的具体步骤：

1. 把起始点（你）放入队列，并标记为“已访问”。
    
2. 只要队列不为空：
    
    - 从队列头部取出一个顶点。
        
    - 访问该点的所有**未被访问过**的邻居。
        
    - 将这些邻居放入队列，并标记为“已访问”。
```cpp
#include <queue>

// 在 Graph 类中添加此方法
void BFS(int startVertex) {
    vector<bool> visited(numVertices, false); // 标记数组
    queue<int> q;

    visited[startVertex] = true;
    q.push(startVertex);

    while (!q.empty()) {
        int currVertex = q.front();
        cout << "正在访问: " << currVertex << endl;
        q.pop();

        // 遍历当前顶点的所有邻居
        for (int neighbor : adjLists[currVertex]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}
```
### 深度优先搜索（DFS）
[图的深度优先遍历](图的深度优先遍历.pdf)
递归访问邻居
```cpp
// 在 Graph 类中添加
// 邻接表
void DFS(int currVertex, vector<bool>& visited) {
    // 1. 访问当前节点
    visited[currVertex] = true;
    cout << "正在访问: " << currVertex << endl;

    // 2. 递归访问每一个未被发现的邻居
    for (int neighbor : adjLists[currVertex]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited);
        }
    }
}
void DFS(int from,vector<vector<int>>& graph,vector<bool>& visited){
    visited[from] = true;
    cout << "正在访问：" << from <<endl;
    for(int to:graph[from]){
       if(!visited[to]){
          DFS(to,graph,visited);
       }
    }
}
```

：
### 连通性问题
    
[求无向图连通子图](求无向图连通子图.pdf)：基于顶点和边信息，计算连通子图个数及各连通子图的顶点个数（升序输出）。**使用DFS或者BFS遍历** 
[高铁网络-最少建设高铁线路问题](高铁网络-最少建设高铁线路问题.pdf)：实质是求连通分量个数减一，以确定最少还需建设的高铁线路数。
## 2 最短路径
### Dijkstra算法（单个点对点）
[网络时延-节点信号传递最短时间计算](网络时延-节点信号传递最短时间计算.pdf)
Dijkstra 算法是一种用于计算图中单源最短路径的算法，**其本质是标准 BFS 算法 + 贪心思想**。如果图中包含负权重边，会让贪心思想失效，所以 **Dijkstra 只能处理不包含负权重边的图**。
Dijkstra 算法和标准的 BFS 算法的区别只有两个：
1、标准 BFS 算法使用普通队列，Dijkstra 算法使用优先级队列，让距离起点更近的节点优先出队（贪心思想的体现）。
2、标准 BFS 算法使用一个 `visited` 数组记录访问过的节点，确保算法不会陷入死循环；Dijkstra 算法使用一个 `distTo` 数组，确保算法不会陷入死循环，同时记录起点到其他节点的最短路径。
### Floyd算法（所有点）
[求图中任意两顶点最短路径](求图中任意两顶点最短路径.pdf)
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 205;

// dist[i][j]: 最短距离
int dist[MAXN][MAXN];
// path[i][j]: 从 i 到 j 的最短路径上，i 的下一个节点
int path[MAXN][MAXN]; 

int n, m;

void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            if (dist[i][k] == INF) continue; // 剪枝
            
            for (int j = 1; j <= n; j++) {
                if (dist[k][j] == INF) continue;

                // 如果经过 k 能缩短距离
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    
                    // 【核心修改】：
                    // 从 i 到 j 的新路径是先去 k，所以 i 的下一步应该跟随 i->k 的路径走
                    path[i][j] = path[i][k];
                }
            }
        }
    }
}

// 打印路径的辅助函数
void printPath(int start, int end) {
    if (start == end) {
        cout << start << endl;
        return;
    }
    
    if (dist[start][end] == INF) {
        cout << "从 " << start << " 到 " << end << " 不可达" << endl;
        return;
    }

    cout << "路径: " << start;
    int curr = start;
    // 不断寻找下一个节点，直到到达终点
    while (curr != end) {
        curr = path[curr][end]; // 这里的含义是：在当前点 curr，要去 end，下一步该去哪？
        cout << " -> " << curr;
    }
    cout << endl;
}
```


    
	
	
	

[网络时延-节点信号传递最短时间计算](网络时延-节点信号传递最短时间计算.pdf)
## 3 最小生成树
### Prim 算法（加点法）
#### 1. 核心思想 (加点法)

Prim算法是一种**贪心算法**，它的策略类似于“寻找最近的邻居”。

- **切入点**：从任意一个节点开始（比如节点1）。
    
- **过程**：维护一个集合，分为“已在树中的点”和“未在树中的点”。每次从“未在树中的点”里，找到一条连接“已在树中点”且权值最小的边，将该点加入树中。
    
- **重复**：直到所有点都被加入树中。
    

#### 2. 数据结构

- **邻接表**：存储图结构。
    
- **dist[] 数组**：记录当前“非树节点”到“树集合”的最短距离。
    
- **vis[] 数组**：标记节点是否已经加入了最小生成树。
    
- **优先队列 (Priority Queue)**：用于快速获取当前距离最小的节点（优化版核心）。
    

### Kruskal算法(加边法)
#### 1. 核心思想 (加边法)

Kruskal算法的策略更加直观，它基于边的权值进行贪心。

- **排序**：将图中所有的边按权值**从小到大**排序。
    
- **遍历**：依次枚举每一条边。
    
- **判断**：如果这条边的两个端点**不属于同一个连通分量**（即不会形成环），就将这条边加入最小生成树，并合并这两个分量。
    
- **结束**：当选中了N-1条边时，算法结束。

#### 2. 数据结构

- **结构体数组**：存储所有边 (u, v, w)。
    
- **并查集 (Union-Find / DSU)**：这是Kruskal的灵魂。用于快速判断两个点是否在同一个集合，以及合并两个集合。

[最小生成树-克鲁斯卡尔算法求无向网最小生成树](最小生成树-克鲁斯卡尔算法求无向网最小生成树.pdf)基于顶点数、边数及带权边信息，使用Kruskal算法输出最小生成树的边集（按顺序，且第一个顶点编号小于第二个）。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 定义边的结构体
struct Edge {
    int u, v, w;
    // 重载 < 运算符，用于 sort 排序
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

// 并查集结构
struct DSU {
    vector<int> parent;
    
    DSU(int n) {
        parent.resize(n + 1);
        for (int i = 0; i <= n; i++) parent[i] = i;
    }

    // 查找根节点（含路径压缩）
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 合并两个集合
    // 返回 true 表示合并成功（原本不在一组）
    // 返回 false 表示已经在同一组（会形成环）
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
            return true;
        }
        return false;
    }
};

int kruskal(int n, vector<Edge>& edges) {
    // 1. 按权值从小到大排序
    sort(edges.begin(), edges.end());

    DSU dsu(n);
    int total_weight = 0;
    int edges_count = 0;

    // 2. 遍历边
    for (const auto& edge : edges) {
        // 3. 如果两个点不在同一个集合，则合并
        if (dsu.unite(edge.u, edge.v)) {
            total_weight += edge.w;
            edges_count++;
        }
        // 剪枝：如果已经选了 n-1 条边，说明树已生成完毕
        if (edges_count == n - 1) break;
    }

    // 如果边数不够 n-1，说明图不连通
    if (edges_count < n - 1) return -1;

    return total_weight;
}

int main() {
    int n = 4; // 点的数量
    vector<Edge> edges = {
        {1, 2, 1}, {1, 3, 2}, {1, 4, 3},
        {2, 3, 2}, {3, 4, 4}
    };

    int result = kruskal(n, edges);

    if (result != -1)
        cout << "Kruskal Algorithm MST Weight: " << result << endl;
    else
        cout << "Graph is not connected." << endl;

    return 0;
}

```
#### Union Find并查集算法
```cpp
class UF {
private:
    // 连通分量个数
    int _count;
    // 存储每个节点的父节点
    vector<int> parent;

public:
    // n 为图中节点的个数
    UF(int n) {
        this->_count = n;
        this->parent.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 将节点 p 和节点 q 连通
    void union_(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        
        if (rootP == rootQ)
            return;
        
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        _count--;
    }

    // 判断节点 p 和节点 q 是否连通
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 返回图中的连通分量个数
    int count() {
        return _count;
    }
};
```
## 4 拓扑排序（判断环）
**核心思想（有向无环图）：** 每次选入度为0的点，然后提取这个点并删掉它的出边
**如果拓扑排序进行不下去说明图中存在环**

[判断有向图中是否有环](判断有向图中是否有环.pdf)： 基于有向图的邻接矩阵，判断图中是否存在环，输出结果为1（有环）或0（无环）。


## 5 关键路径
    
[关键路径-计算AOE-网中关键路径长度](关键路径-计算AOE-网中关键路径长度.pdf)基于AOE网的邻接矩阵（0表示无弧，正数表示活动时间），计算关键路径长度，若网中有环则输出"NO"。


