[数据结构复习回顾](数据结构复习回顾.pdf)
[期末查漏补缺](期末查漏补缺.md)

首先从**第一章：绪论（基础概念与算法分析）**开始。

---

### 第一章：基础概念与算法分析

这一章是整个数据结构的基石，主要考察基本概念的记忆以及算法时间复杂度的计算能力。

#### 1. 详细知识点讲解

**A. 基本术语**
*   **数据 (Data)**：信息的载体。
*   **数据元素 (Data Element)**：数据的基本单位（在数据库中通常称为“记录”）。
*   **数据项 (Data Item)**：构成数据元素的最小单位（不可分割，在数据库中称为“字段”）。
    *   *关系*：数据 > 数据元素 > 数据项。
*   **数据结构 (Data Structure)**：
    *   定义：相互之间存在一种或多种特定关系的数据元素的集合。
    *   形式定义（二元组）：$DS = (D, R)$，其中 $D$ 是数据元素集合，$R$ 是关系的集合。
*   **抽象数据类型 (ADT)**：
    *   定义：一个数学模型以及定义在该模型上的一组操作。
    *   形式定义（三元组）：$(D, R, P)$，即数据对象、数据关系、基本操作。

**B. 数据的逻辑结构与存储结构（重中之重）**
*   **逻辑结构**（跟怎么存在电脑里无关，只看元素间的逻辑关系）：
    1.  **线性结构**：一对一关系（如：线性表、栈、队列、串）。
    2.  **非线性结构**：一对多或多对多（如：树、图、多维数组）。
*   **存储结构**（物理结构，数据在计算机内存中的映射）：
    1.  **顺序存储**：逻辑上相邻，物理上也相邻（借助数组实现）。
        *   *优点*：随机存取（通过下标直接访问），节省空间（不用存指针）。
        *   *缺点*：插入删除需要移动大量元素，需要预分配空间（可能造成浪费或溢出）。
    2.  **链式存储**：逻辑上相邻，物理上不一定相邻（借助指针实现）。
        *   *优点*：插入删除方便（只改指针），动态分配内存。
        *   *缺点*：不能随机存取，指针占用额外空间。
    *   *注*：除了这两种，还有索引存储和散列存储（哈希），但前两者最常用。

**C. 算法分析**[复杂度计算](复杂度计算.md)
*   **时间复杂度**：
    *   **大 O 表示法**：表示随问题规模 $n$ 增大，算法执行时间的增长率。
    *   常见排序：$O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n)$。
    *   重点在于分析循环的次数和递归的深度。
*   **空间复杂度**：算法在运行过程中临时占用存储空间的大小（包括辅助变量、递归栈空间等）。

---

#### 2. 本章核心考点（必须掌握）

1.  **区分逻辑结构与存储结构**：
    *   考题常问：“链表是逻辑结构还是存储结构？”（答案：链表通常指链式存储的线性表，侧重存储；但“线性表”是逻辑结构）。
    *   有序表是指元素按值有序，是逻辑概念；而顺序表是存储概念。
2.  **计算时间复杂度（必考题）**：
    *   给出一在一个或双重循环的代码段，让你写出 $T(n)$。
    *   特别注意 $i = i * 2$ 这种循环，复杂度是 $\log_2 n$。
3.  **顺序存储 vs 链式存储的优缺点**：
    *   通常出现在选择题或简答题中，询问在特定场景（如频繁插入、频繁查找）下选哪种结构。

---

#### 3. 典型例题与解析

**例题 1：时间复杂度计算**
**题目**：求以下代码段的时间复杂度。
```c
int i = 1;
while (i <= n) {
    i = i * 2;
}
```
**解析**：
*   假设循环执行了 $x$ 次。
*   每次循环 $i$ 都在翻倍，所以 $2^x \le n$。
*   解得 $x \le \log_2 n$。
*   **答案**：$O(\log n)$。

**例题 2：嵌套循环复杂度**
**题目**：求以下代码段的时间复杂度。
```c
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // ... O(1) 的操作
    }
}
```
**解析**：
*   外层循环执行 $n$ 次。
*   内层循环对于每个 $i$ 都执行 $n$ 次。
*   总次数 $n \times n = n^2$。
*   **答案**：$O(n^2)$。
*   *变式*：如果内层是 `for (int j = 0; j < i; j++)`？
    *   总次数为 $0 + 1 + 2 + \dots + (n-1) = n(n-1)/2$。
    *   保留最高阶项，**答案**依然是 $O(n^2)$。

**例题 3：概念辨析（选择题）**
**题目**：以下关于数据结构的说法中，正确的是（ ）。
A. 数据的逻辑结构独立于其存储结构
B. 数据的存储结构独立于其逻辑结构
C. 数据的逻辑结构唯一决定了其存储结构
D. 数据结构仅包含数据元素之间的关系
**解析**：
*   A 正确。逻辑结构（如线性表）是抽象的，跟怎么存在电脑里（数组还是链表）没关系。
*   B 错误。存储结构是逻辑结构的实现，不能完全脱离逻辑结构。
*   C 错误。一种逻辑结构（如线性表）可以有多种存储结构（顺序表、链表）。
*   D 错误。数据结构包含数据元素（D）和关系（R）。
*   **答案**：A

**例题 4：存储结构选择**
**题目**：若某线性表最常用的操作是存取第 $i$ 个元素及其前驱的值，则最节省时间的存储方式是（ ）。
A. 单链表
B. 双向链表
C. 单循环链表
D. 顺序表
**解析**：
*   题目强调“存取第 $i$ 个元素”（随机访问）。
*   链表访问第 $i$ 个元素需要 $O(n)$ 时间扫描，而顺序表只需要 $O(1)$。
*   虽然找前驱双向链表方便，但顺序表找前驱也是 $O(1)$（即下标 $i-1$）。
*   **答案**：D

---


---

### 第二章：线性表 (Linear List)

#### 1. 详细知识点讲解

**A. 线性表的定义**
*   **定义**：具有相同数据类型的 $n$ ($n \ge 0$) 个数据元素的有限序列。
*   **特征**：除了第一个元素和最后一个元素外，每个元素都有唯一的“前驱”和唯一的“后继”。

**B. 顺序存储结构（顺序表）**
*   **实现**：通常用数组（Array）实现。在内存中分配一段连续的空间。
*   **核心特点**：
    *   **随机访问**：可以通过下标直接访问任意元素，时间复杂度 $O(1)$。
    *   **插入/删除困难**：插入或删除一个元素，通常需要移动大量后续元素，平均时间复杂度 $O(n)$。
*   **存储密度**：高（不需要存指针，只存数据）。

**C. 链式存储结构（链表）**[链表模板](链表.md)
*   **实现**：通过指针将一组零散的内存块串联起来。
*   **核心特点**：
    *   **顺序访问**：访问第 $i$ 个元素必须从头开始遍历，时间复杂度 $O(n)$。
    *   **插入/删除方便**：只要知道位置（指针），修改指针指向即可，不需要移动数据，复杂度 $O(1)$。
*   **带头结点的单链表**（**重点**）：
    *   在第一个数据节点之前附加一个节点（头结点），其 `data` 域不存有效数据（或存长度），`next` 域指向第一个实际数据节点。
    *   *好处*：统一了对空表和非空表的操作，也统一了对第一个节点和其他节点的操作。

**D. 链表的分类（考点密集区）**
1.  **单链表**：只有一个 `next` 指针，单向遍历。
2.  **双向链表**：有 `prior`（前驱）和 `next`（后继）两个指针。
    *   *优点*：可以双向遍历，查找前驱节点方便（$O(1)$）。
    *   *难点*：插入和删除时需要修改 4 个指针方向，顺序不能乱。
3.  **循环链表**：
    *   **单循环**：最后一个节点的 `next` 指向头结点（而不是 NULL）。
    *   **双向循环**：头结点的 `prior` 指向尾节点，尾节点的 `next` 指向头结点。
    *   *判空/判满条件*：判断遍历是否结束的条件不再是 `p->next == NULL`，而是 `p->next == head`（回到头结点）。

---

#### 2. 本章核心考点（必须掌握）

1.  **指针操作代码（填空/大题）**：
    *   **单链表插入**：在节点 $p$ 后插入节点 $s$。
        *   `s->next = p->next;` (先把 s 的右手搭在后面人身上)
        *   `p->next = s;` (再把 p 的右手搭在 s 身上)
        *   *注意*：这两句顺序**绝对不能反**，否则 $p$ 后面的链就断了（丢失了）。
    *   **单链表删除**：删除节点 $p$ 后的节点 $q$。
        *   `q = p->next;`
        *   `p->next = q->next;`
        *   `free(q);`
    *   **双向链表插入**：在 $p$ 后面插入 $s$（假设 $p$ 不是尾节点）。
        1. `s->next = p->next;`
        2. `p->next->prior = s;` (注意这一步，如果不先做，p->next 就变了)
        3. `s->prior = p;`
        4. `p->next = s;`

2.  **顺序表 vs 链表的选择**：
    *   **选顺序表**：知道大概长度、很少插入删除、主要是查询（随机存取）。
    *   **选链表**：长度变化大、频繁插入删除、不需要随机访问。

3.  **头结点的作用**：
    *   常考简答题：为什么引入头结点？（答：1. 便于首元结点的处理；2. 便于空表和非空表的统一处理）。

---

#### 3. 典型例题与解析

**例题 1：单链表插入操作（代码逻辑）**
**题目**：在带头结点的单链表中，指针 $p$ 指向某节点，要在 $p$ 之后插入一个新节点 $s$，下列语句序列正确的是（ ）。
A. `p->next = s; s->next = p->next;`
B. `s->next = p->next; p->next = s;`
C. `p->next = s->next; s->next = p;`
D. `s->next = p; p->next = s->next;`
**解析**：
*   A 选项：第一句执行完，`p->next` 已经指向 `s` 了。第二句变成 `s->next = s`，自己指自己，死循环，且原链表断裂。
*   B 选项：先保存 `p` 原来的后继给 `s`，再让 `p` 指向 `s`。正确。
*   **答案**：B

**例题 2：双向循环链表的操作**
**题目**：在双向循环链表中，在 $p$ 指针所指的节点之前插入一个节点 $s$，操作序列是？
**解析**：
*   在 $p$ 之前插入 $s$，实际上是在 $p->prior$ 和 $p$ 之间插入 $s$。
*   逻辑如下：
    1.  `s->prior = p->prior;` (s 左手连上前一个人)
    2.  `p->prior->next = s;` (前一个人的右手连上 s)
    3.  `s->next = p;` (s 右手连上 p)
    4.  `p->prior = s;` (p 左手连上 s)
*   *注意*：步骤 1 和 2 必须在 4 之前完成，否则 $p$ 的前驱就找不到了。

**例题 3：存储结构特点对比**
**题目**：对于一个线性表，如果经常要存取第 $i$ 个元素，并且不经常进行插入和删除操作，则应当采用（ ）存储结构。
**解析**：
*   关键词：“存取第 $i$ 个元素”（随机访问）。
*   顺序表支持随机访问 $O(1)$，链表需要遍历 $O(n)$。
*   **答案**：顺序表。

**例题 4：链表长度相关**
**题目**：已知指针 $h$ 指向一个带头结点的非空单循环链表，若要删除表尾节点，需要先找到表尾节点的前驱。若链表长度为 $n$，则该操作的时间复杂度为（ ）。
A. $O(1)$
B. $O(n)$
C. $O(\log n)$
D. $O(n^2)$
**解析**：
*   单循环链表只有一个方向。要找尾节点的前驱，必须从头开始遍历，直到 `p->next->next == h`。
*   需要遍历整个链表。
*   **答案**：B
*   *追问*：如果是双向循环链表呢？
    *   答：$O(1)$。因为 `h->prior` 就是尾节点，`h->prior->prior` 就是尾节点的前驱。

---



---

### 第三章：栈 (Stack) 和 队列 (Queue)

这两种数据结构本质上都是**线性表**，但是它们的操作受到了限制（操作受限的线性表）。

#### 1. 详细知识点讲解

**A. 栈 (Stack) —— 后进先出 (LIFO)**
*   **定义**：只允许在一端（栈顶 Top）进行插入和删除操作的线性表。另一端称为栈底（Bottom）。
*   **特点**：**LIFO** (Last In First Out)，最后进去的元素最先出来。
*   **存储结构**：
    *   **顺序栈**：利用一组地址连续的存储单元存放数据。需要一个指针 `top` 指示当前栈顶位置。
        *   *注意*：`top` 的定义不同，代码写法不同：
            *   若 `top` 指向**当前栈顶元素**：进栈是先 `top++` 再赋值。
            *   若 `top` 指向**下一个空位置**：进栈是先赋值再 `top++`。
            *   *考试技巧*：通常默认 `top` 初始化为 -1（指向当前元素），或者 `top` 初始化为 0（指向下一个空位），看题干具体设定。
    *   **链栈**：通常用单链表实现，栈顶就在表头（head），插入删除都在头结点处进行，不需要判断栈满。
*   **应用**：递归（函数调用栈）、括号匹配、表达式求值（中缀转后缀）、迷宫求解（深度优先搜索 DFS）。

**B. 队列 (Queue) —— 先进先出 (FIFO)**
*   **定义**：只允许在表的一端（队尾 Rear）进行插入，在另一端（队头 Front）进行删除。
*   **特点**：**FIFO** (First In First Out)，排队买票，先来的先买。
*   **存储结构**：
    *   **链队列**：带头指针 `front` 和尾指针 `rear` 的单链表。
    *   **顺序队列与“假溢出”**：
        *   如果用普通数组做队列，`front` 和 `rear` 一直往后移，前面的空间空着却用不了，这叫“假溢出”。
        *   **解决方案**：使用**循环队列**（重点）。

**C. 循环队列 (Circular Queue) —— 本章最核心计算点**
*   **概念**：把数组视为一个环，下标走到 `maxSize-1` 后，下一个位置回到 `0`。
*   **核心公式（模运算 `%`）**：
    1.  **入队下标变化**：`rear = (rear + 1) % maxSize`
    2.  **出队下标变化**：`front = (front + 1) % maxSize`
    3.  **计算队列长度**（元素个数）：`(rear - front + maxSize) % maxSize`
*   **判空与判满**（难点）：
    *   如果不做特殊处理，`front == rear` 既可能表示空，也可能表示满。
    *   **通用解法（牺牲一个存储单元）**：
        *   **队空条件**：`front == rear`
        *   **队满条件**：`(rear + 1) % maxSize == front` （即队尾追上了队头，还差一步）

---

#### 2. 本章核心考点（必须掌握）

1.  **栈的合法输出序列（必考选择题）**：
    *   给一个输入序列（如 1, 2, 3, 4），判断哪一个**不是**合法的输出序列。
    *   *规律*：如果输出序列中出现了某元素 $k$，那么在 $k$ 后面输出的所有比 $k$ 小的元素，必须是**降序**排列的。（因为它们一定已经在栈里了，只能依次弹出）。
2.  **循环队列的计算**：
    *   尤其是计算下标、判断队满条件。
    *   一定要注意题干是从 0 开始还是从 1 开始，`rear` 是指向最后一个元素还是下一个空位。
3.  **递归与栈**：
    *   理解递归的本质是系统隐含地使用了栈来保存每一层函数的参数和返回地址。

---

#### 3. 典型例题与解析

**例题 1：栈的合法输出序列**
**题目**：设栈的输入序列是 1, 2, 3, 4，则**不合法**的输出序列是（ ）。
A. 3, 2, 1, 4
B. 2, 3, 4, 1
C. 4, 2, 3, 1
D. 1, 4, 3, 2
**解析**：
*   A: 进1,2,3 -> 出3,2,1 -> 进4 -> 出4。合法。
*   B: 进1,2 -> 出2 -> 进3 -> 出3 -> 进4 -> 出4 -> 出1。合法。
*   C: 要先输出 4，必须 1,2,3,4 全部进栈。此时栈内从底到顶是 1,2,3,4。
    *   出 4 后，栈顶是 3。必须出 3，才能遇到 2。
    *   但选项 C 在 4 之后跳过 3 直接出了 2，这是不可能的。
*   D: 进1 -> 出1 -> 进2,3,4 -> 出4,3,2。合法。
*   **答案**：C

**例题 2：循环队列的队满条件**
**题目**：设循环队列的存储空间为 `Q[0..m-1]`，`front` 指向队头元素，`rear` 指向队尾元素的**下一个位置**。若采取“牺牲一个单元”的方法区分空满，则队满的条件是（ ）。
A. `rear == front`
B. `(front + 1) % m == rear`
C. `(rear + 1) % m == front`
D. `rear + 1 == front`
**解析**：
*   `front == rear` 是判空条件。
*   队满意味着 `rear` 再往前走一步就撞到 `front` 了（因为是循环的，所以要取模）。
*   公式：`(rear + 1) % m == front`。
*   **答案**：C

**例题 3：循环队列的元素个数**
**题目**：循环队列大小 `maxSize = 10`，`front = 8`, `rear = 2`（`rear` 指向下一空位）。求队列中有多少个元素？
**解析**：
*   直观想：从 8 到 9，再回到 0, 1。元素分别在下标 8, 9, 0, 1。共 4 个。
*   套公式：`(rear - front + maxSize) % maxSize`
    *   $= (2 - 8 + 10) % 10$
    *   $= 4 % 10 = 4$
*   **答案**：4 个。
*   *易错点*：直接用 `2 - 8 = -6`，忘记加 `maxSize` 就做模运算。

**例题 4：栈与递归**
**题目**：一个递归算法必须包括（ ）。
A. 递归部分
B. 终止条件
C. 递归部分和终止条件
D. 循环结构
**解析**：
*   递归必须有基准情况（终止条件）来结束递归，否则会栈溢出。也必须有递归部分来缩小问题规模。
*   **答案**：C

---


---

### 第四章：串 (String)

#### 1. 详细知识点讲解

**A. 串的基本概念**
*   **定义**：串是由零个或多个字符组成的有限序列。
*   **本质**：特殊的线性表，数据元素限定为**字符**。
*   **术语**：
    *   **子串**：串中任意连续字符组成的子序列。
    *   **主串**：包含子串的串。
    *   **位置**：字符在串中的序号（通常从 1 开始）。
    *   **相等**：长度相等，且对应位置的字符都相等。

**B. 串的存储结构**
*   **定长顺序存储**：用固定长度的数组存（类似于 C 语言的 `char str[100];`）。
*   **堆分配存储**：动态分配内存（malloc），用指针指向起始地址。
*   **块链存储**：用链表存，为了节省指针空间，一个节点通常存放多个字符（如 4 个字符一个节点）。

**C. 模式匹配算法（核心）**
*   **目标**：在主串 $S$ 中找到子串 $T$（模式串）的位置。
*   **朴素模式匹配 (Brute-Force)**：
    *   暴力法。主串指针 $i$ 和模式串指针 $j$ 一起走。
    *   一旦不匹配，$i$ 回溯到上一次开始位置的下一个（$i = i - j + 2$），$j$ 回溯到 1。
    *   *缺点*：速度慢，最坏时间复杂度 $O(n \times m)$。
*   **KMP 算法 (Knuth-Morris-Pratt)**：
    *   *核心思想*：**主串指针 $i$ 不回溯**，利用已经匹配过的信息，只把模式串向右滑动（即调整 $j$ 的位置）。
    *   *时间复杂度*：$O(n + m)$。

---

#### 2. 本章核心考点（必须掌握）

**唯一真神：KMP 算法的 `next` 数组计算**

这是本章 90% 的考点所在。题目通常会给出一个模式串，让你写出它的 `next` 数组值。

**手工计算 `next` 数组的方法（应试通法，1-based 索引）**：
假设模式串为 $P$，长度为 $m$，下标从 1 开始。`next[j]` 的含义是：当第 $j$ 个字符匹配失败时，指针 $j$ 应该跳到哪里。

*   **规则**：
    1.  `next[1] = 0` （固定死，表示第一个就没匹配上，主串指针 $i$ 要往前走，模式串从头开始）。
    2.  `next[2] = 1` （固定死，表示第二个没匹配上，跳回第 1 个试试）。
    3.  **对于 $j > 2$**：看 $P[1 \dots j-1]$ 这个子串（即当前字符**前面**的所有字符）。寻找这个子串的**最长相等前后缀**的长度。
        *   `next[j] = 最长相等前后缀长度 + 1`。

**通俗口诀**：
“看前面，找重复。头尾重合几个字，加 1 就是下一步。”

---

#### 3. 典型例题与解析（手把手教算 KMP）

**例题 1：计算 Next 数组（经典）**
**题目**：求模式串 `T = 'abaabc'` 的 `next` 数组。

**解析步骤**：
下标 $j$ | 1 | 2 | 3 | 4 | 5 | 6 | 字符 $T[j]$
--- | --- | --- | --- | --- | --- | --- | ---
**字符** | **a** | **b** | **a** | **a** | **b** | **c** |

1.  **$j=1$**: `next[1] = 0` (规定)。
2.  **$j=2$**: `next[2] = 1` (规定)。
3.  **$j=3$**: 看前面 `'ab'`。前缀 `'a'`，后缀 `'b'`。相等吗？不等。重合长度 0。
    *   `next[3] = 0 + 1 = 1`。
4.  **$j=4$**: 看前面 `'aba'`。
    *   前缀 `'a'`, `'ab'`
    *   后缀 `'a'`, `'ba'`
    *   最长相等前后缀是 `'a'` (长度 1)。
    *   `next[4] = 1 + 1 = 2`。
5.  **$j=5$**: 看前面 `'abaa'`。
    *   前缀 `'a'`, `'ab'`, `'aba'`
    *   后缀 `'a'`, `'aa'`, `'baa'`
    *   最长相等前后缀是 `'a'` (长度 1)。
    *   `next[5] = 1 + 1 = 2`。
6.  **$j=6$**: 看前面 `'abaab'`。
    *   前缀 `'a'`, `'ab'`, `'aba'`, `'abaa'`
    *   后缀 `'b'`, `'ab'`, `'aab'`, `'baab'`
    *   注意看！前缀 `'ab'` 和后缀 `'ab'` 相等（长度 2）。
    *   `next[6] = 2 + 1 = 3`。

**最终结果**：
`next` 数组序列为：**0, 1, 1, 2, 2, 3**

**例题 2：Next 数组含义**
**题目**：在 KMP 算法中，若模式串 `T` 的 `next[j] = k`，这说明（ ）。
A. 模式串中第 $j$ 个字符与主串中第 $k$ 个字符不等
B. 模式串中第 $k$ 个字符与主串中第 $j$ 个字符不等
C. 模式串 $T[1 \dots k-1]$ 与 $T[j-k+1 \dots j-1]$ 相同
D. 主串中对应的子串与 $T[1 \dots k-1]$ 相同
**解析**：
*   `next[j] = k` 意味着在 $j$ 处失配后，下一步用第 $k$ 个字符去跟主串比较。
*   这之所以成立，是因为模式串的前 $k-1$ 个字符（前缀）和 $j$ 之前的 $k-1$ 个字符（后缀）是完全一样的。
*   **答案**：C （这就是最长相等前后缀的定义）。

**例题 3：Nextval 数组（进阶考点，了解即可）**
*   有时考题会求 `nextval`（修正后的 next 数组）。
*   **规则**：如果 `T[j] == T[next[j]]`，则 `nextval[j] = nextval[next[j]]`；否则 `nextval[j] = next[j]`。
*   *目的*：如果跳过去发现字符跟刚才失配的字符一样，那肯定还得失配，不如一步到位跳得更远。

---


---

### 第五章：数组和广义表

#### 1. 详细知识点讲解

**A. 数组的顺序存储与地址计算（必考公式）**
计算机内存是一维的（线性的），而数组通常是二维或多维的。要将二维数据存入一维内存，有两种方式：
1.  **按行优先存储 (Row-Major Order)**：一行一行地存（C/C++、Java 默认方式）。
    *   先存第 0 行，再存第 1 行……
2.  **按列优先存储 (Column-Major Order)**：一列一列地存（Fortran、MATLAB 默认方式）。
    *   先存第 0 列，再存第 1 列……

**通用计算公式（假设数组 $A[M][N]$，即 $M$ 行 $N$ 列）**：
*   设每个元素占 $L$ 个存储单元，基地址为 $Base$。
*   **按行优先**，求元素 $A[i][j]$ 的地址：
    *   **0-based (下标从0开始)**：$LOC(i, j) = Base + (i \times N + j) \times L$
        *   *理解*：前面已经存满了 $i$ 行（每行 $N$ 个），当前行前面还有 $j$ 个元素。
    *   **1-based (下标从1开始)**：$LOC(i, j) = Base + ((i-1) \times N + (j-1)) \times L$
*   **按列优先**，求元素 $A[i][j]$ 的地址：
    *   **0-based**：$LOC(i, j) = Base + (j \times M + i) \times L$
        *   *理解*：前面已经存满了 $j$ 列（每列 $M$ 个），当前列前面还有 $i$ 个元素。

**B. 特殊矩阵的压缩存储**
为了节省空间，对有规律的矩阵只存储有效数据。
1.  **对称矩阵**：$a_{ij} = a_{ji}$。
    *   策略：只存**下三角**（或上三角）。
    *   **关键点**：将二维坐标 $(i, j)$ 映射到一维数组下标 $k$。
    *   *公式（下三角，按行优先，下标从 0 开始，且 $i \ge j$）*：
        $k = \frac{i(i+1)}{2} + j$
        *   *推导*：第 0 行 1 个，第 1 行 2 个……第 $i-1$ 行 $i$ 个。这是一个等差数列求和。
2.  **三角矩阵**：除了上/下三角，其余全是常数 $c$。
3.  **稀疏矩阵**：大部分是 0，只有少部分非零元素。
    *   **三元组表**：用 `(row, col, value)` 存储每个非零元素。
    *   **十字链表**：用于复杂的矩阵运算。

**C. 广义表 (Generalized List)**
*   **定义**：线性表的推广。元素可以是原子（单个数据），也可以是子表（另一个广义表）。
    *   例如：$LS = (a, (b, c), d)$。长度为 3，元素为 原子$a$、子表$(b,c)$、原子$d$。
*   **深度**：括号嵌套的最大层数。
*   **重要运算（核心考点）**：
    1.  **取表头 (GetHead)**：取出的**第一个元素**。可以是原子，也可以是子表。
    2.  **取表尾 (GetTail)**：除去表头后，**剩下的所有元素组成的表**。
        *   **注意**：**表尾一定是一个表**（即外面一定要套一层括号）。

---

#### 2. 本章核心考点（必须掌握）

1.  **地址计算避坑指南**：
    *   **看清行列**：题目说是按行存还是按列存？
    *   **看清起始下标**：是从 0 开始还是从 1 开始？
    *   **看清矩阵维度**：是 $M$ 行 $N$ 列，还是 $N$ 行 $M$ 列？（公式里的乘数取决于每行/每列有多少个元素）。
2.  **对称矩阵下标转换**：
    *   常考：给一个对称矩阵 $A$，按行存储下三角，问 $A[i][j]$ 在一维数组中的下标 $k$ 是多少？
    *   注意：如果 $i < j$（在上三角区域），要先利用对称性交换 $i, j$，变成 $A[j][i]$ 再套公式。
3.  **广义表 Head/Tail 运算**：
    *   考题通常是一串连续的 Head/Tail 操作，让你写出结果。

---

#### 3. 典型例题与解析

**例题 1：数组地址计算**
**题目**：有一个二维数组 $A[10][20]$（10行20列），每个元素占 2 个字节。设 $A[0][0]$ 的地址为 1000。若按**列优先**存储，求元素 $A[5][10]$ 的存储地址。
**解析**：
*   **维度**：行数 $M=10$，列数 $N=20$。
*   **存储方式**：按列优先。
*   **下标**：从 0 开始。
*   **公式**：$LOC(i, j) = Base + (j \times \text{行数} + i) \times L$
    *   这里 $i=5, j=10$。
    *   前面存满了 $10$ 列（第 0 到第 9 列）。每列有 $10$ 个元素。
    *   偏移量 = $(10 \times 10 + 5) \times 2$
    *   $= (100 + 5) \times 2 = 210$
*   **地址**：$1000 + 210 = 1210$。
*   *易错点*：按列存储要乘以行数（因为一列有 M 个元素）；如果按行存储就要乘以列数。

**例题 2：对称矩阵压缩**
**题目**：将 $n$ 阶对称矩阵 $A$ 的下三角元素按行优先存入一维数组 $B[1 \dots n(n+1)/2]$ 中。若 $A[i][j]$ ($i, j \ge 1$) 存放在 $B[k]$ 中，则 $k$ 与 $i, j$ 的关系是（假设 $i \ge j$）？
**解析**：
*   下标从 1 开始。
*   目标元素在第 $i$ 行。
*   前 $i-1$ 行（第 1 到 $i-1$ 行）的总元素个数：$1 + 2 + \dots + (i-1) = \frac{(i-1)i}{2}$。
*   第 $i$ 行中，前 $j-1$ 个元素已经存了，当前是第 $j$ 个。
*   所以 $k = \frac{i(i-1)}{2} + j$。
*   **答案**：$k = \frac{i(i-1)}{2} + j$。

**例题 3：广义表运算（易错）**
**题目**：广义表 $L = ((a, b), (c, d))$，求 `Head(Tail(L))` 的结果。
**解析**：
1.  **Tail(L)**：
    *   $L$ 有两个元素：$e_1 = (a, b)$, $e_2 = (c, d)$。
    *   取表尾，就是除去 $e_1$，剩下 $e_2$，**并且要加括号**。
    *   `Tail(L) = ((c, d))`。  <-- 注意这里是两层括号！
2.  **Head(...)**：
    *   对 `((c, d))` 取表头。
    *   它的第一个元素是 `(c, d)`。
    *   所以结果是 `(c, d)`。
*   **答案**：`(c, d)`。
*   *对比*：如果是 `Tail(Head(L))`？
    *   `Head(L) = (a, b)`
    *   `Tail((a, b)) = (b)` （注意：b 外面有括号，因为表尾一定是表）。

---


---

### 第六章：树和二叉树 (Tree & Binary Tree)

#### 1. 详细知识点讲解

**A. 基本概念（咬文嚼字）**
*   **结点的度 (Degree)**：一个结点拥有的子树个数（孩子个数）。
*   **树的度**：树内各结点度的**最大值**。
*   **叶子 (Leaf)**：度为 0 的结点（终端结点）。
*   **深度/高度**：树的层数。
*   **二叉树 vs 树**：
    *   二叉树的度不能超过 2。
    *   二叉树是有序的（区分左孩子、右孩子），即使只有一个孩子也要区分左右。

**B. 二叉树的性质（5 个公式 —— 必背计算核心）**
1.  **性质 1**：在二叉树的第 $i$ 层上至多有 $2^{i-1}$ 个结点 ($i \ge 1$)。
2.  **性质 2**：深度为 $k$ 的二叉树至多有 $2^k - 1$ 个结点 ($k \ge 1$)。
3.  **性质 3（重中之重）**：对任何一棵二叉树，如果其**叶子结点数**为 $n_0$，**度为 2 的结点数**为 $n_2$，则 **$n_0 = n_2 + 1$**。
    *   *含义*：叶子永远比分叉最多的结点多一个。
4.  **性质 4**：具有 $n$ 个结点的**完全二叉树**的深度为 $\lfloor \log_2 n \rfloor + 1$。
5.  **性质 5**：完全二叉树的顺序存储编号规律（从 1 开始编号）：
    *   结点 $i$ 的左孩子是 $2i$，右孩子是 $2i+1$。
    *   结点 $i$ 的双亲是 $\lfloor i/2 \rfloor$。

**C. 二叉树的存储**
*   **顺序存储**：适合**完全二叉树**。如果是一般二叉树，会浪费大量空间（因为要补空位对齐下标）。
*   **链式存储（二叉链表）**：最常用。
    *   结构：`lchild | data | rchild`
    *   **空指针问题**：$n$ 个结点的二叉链表中，含有 **$2n$** 个指针域，其中有 **$n+1$** 个空指针域（用于线索化）。

**D. 二叉树的遍历（算法核心）**
*   **先序遍历 (PreOrder)**：根 -> 左 -> 右
*   **中序遍历 (InOrder)**：左 -> 根 -> 右
*   **后序遍历 (PostOrder)**：左 -> 右 -> 根
*   **层次遍历**：使用**队列**实现，从上到下，从左到右。
*   **考点**：知二求一。
    *   已知 **先序 + 中序** $\Rightarrow$ 可唯一确定二叉树。
    *   已知 **后序 + 中序** $\Rightarrow$ 可唯一确定二叉树。
    *   *注意*：已知 **先序 + 后序** $\Rightarrow$ **无法**唯一确定二叉树。

**E. 树、森林与二叉树的转换**
*   **口诀**：“左孩子右兄弟”。
    *   树变二叉树：将第一个孩子作为左孩子，将下一个兄弟作为右孩子。
*   这使得任何树或森林都可以用二叉树的结构来存储。

**F. 线索二叉树**
*   利用那 $n+1$ 个空指针，指向前驱和后继，方便遍历。
*   *考点*：画出线索（虚线箭头）。

**G. 哈夫曼树 (Huffman Tree) 与 WPL**
*   **定义**：带权路径长度 (WPL) 最小的二叉树（最优二叉树）。
*   **构造算法**：每次选两个权值最小的树合并，生成新树（权值为两者之和），直到只剩下一棵。
*   **特点**：哈夫曼树中**没有度为 1 的结点**（只有度为 0 和度为 2 的）。

---

#### 2. 本章核心考点（必须掌握）

1.  **性质 3 的计算应用**：
    *   题目给总结点数 $n$，求叶子数 $n_0$。
    *   解题关键：联立方程组
        1.  $n = n_0 + n_1 + n_2$
        2.  $n_0 = n_2 + 1$
2.  **由遍历序列还原二叉树（画图题）**：
    *   这是必考题，给你两个序列，让你画出树，或者写出第三种序列。
3.  **哈夫曼树的构造与 WPL 计算**：
    *   给一组权值，画出哈夫曼树，算 WPL。
    *   注意 WPL 是 **(叶子权值 $\times$ 路径长度) 之和**，或者更简单的算法是 **所有非叶子结点的权值之和**。

---

#### 3. 典型例题与解析

**例题 1：性质计算**
**题目**：一棵二叉树共有 100 个结点，其中度为 1 的结点有 20 个，求叶子结点的个数。
**解析**：
*   总数 $n = n_0 + n_1 + n_2 = 100$。
*   已知 $n_1 = 20$。
*   代入得：$n_0 + 20 + n_2 = 100 \Rightarrow n_0 + n_2 = 80$。
*   根据性质 3：$n_2 = n_0 - 1$。
*   代入：$n_0 + (n_0 - 1) = 80 \Rightarrow 2n_0 = 81$。
*   *等等，算出 40.5？*
    *   **注意**：二叉树的结点数如果是整数，$2n_0 = 81$ 说明题目数据有误或不存在这样的二叉树。但通常考题会给偶数剩余，例如若 $n=99$，则 $2n_0 = 80 \Rightarrow n_0 = 40$。
    *   **正确逻辑**：$n_0$ 和 $n_2$ 的和必然是奇数（因为差 1），所以 $n - n_1$ 必须是奇数。

**例题 2：完全二叉树的叶子**
**题目**：一棵完全二叉树有 1001 个结点，其叶子结点有多少个？
**解析**：
*   完全二叉树中，度为 1 的结点 $n_1$ 只能是 0 或 1。
*   总数 $n = 1001$ (奇数)。
*   因为 $n_0 + n_2 = 2n_2 + 1$ 总是奇数，而 $n = (n_0 + n_2) + n_1$。
*   奇数 = 奇数 + $n_1 \Rightarrow n_1$ 必须为 0。
*   所以 $n_0 + n_2 = 1001$。
*   又 $n_0 = n_2 + 1$。
*   $2n_0 - 1 = 1001 \Rightarrow 2n_0 = 1002 \Rightarrow n_0 = 501$。
*   **答案**：501 个。

**例题 3：还原二叉树**
**题目**：
先序序列：A B D E C F
中序序列：D B E A C F
求后序序列。
**解析**：
1.  **看先序**：第一个是 **A**，它是根。
2.  **看中序**：A 把序列分成两半。左边 `DBE` 是左子树，右边 `CF` 是右子树。
3.  **递归左子树 `DBE`**：
    *   看先序中 A 后面是 **B**，B 是左子树的根。
    *   看中序中 B 把 `DBE` 分成 `D` (左) 和 `E` (右)。
    *   所以 B 左边是 D，右边是 E。
4.  **递归右子树 `CF`**：
    *   看先序中 `...C F`，**C** 在前，C 是右子树的根。
    *   看中序中 `C F`，C 在 F 左边，说明 F 是 C 的右孩子（C 没有左孩子）。
5.  **画出树**：
        A
       / \
      B   C
     / \   \
    D   E   F
6.  **写后序**（左-右-根）：D E B F C A。
*   **答案**：D E B F C A。

**例题 4：哈夫曼树 WPL**
**题目**：给定权值 {2, 3, 5, 7, 8}，求 WPL。
**解析**：
1.  选最小 2, 3 合并 -> 新权值 5。当前集合 {5, 5, 7, 8}。
2.  选最小 5, 5 合并 -> 新权值 10。当前集合 {7, 8, 10}。
3.  选最小 7, 8 合并 -> 新权值 15。当前集合 {10, 15}。
4.  选最小 10, 15 合并 -> 新权值 25。结束。
*   **计算 WPL**：
    *   方法一（所有非叶子结点之和）：$5 + 10 + 15 + 25 = 55$。
    *   方法二（带权路径法）：画图，看层数。
        *   2 和 3 在第 4 层 (路径 3?) -> $2\times3 + 3\times3 = 15$
        *   *这种方法容易数错层数，推荐方法一：把所有生成的中间圆圈里的数字加起来就是 WPL。*
*   **答案**：55。

---


---

### 第七章：图 (Graph)

#### 1. 详细知识点讲解

**A. 图的定义与术语**
*   **结构**：$G = (V, E)$。$V$ 是顶点(Vertex)集合，$E$ 是边(Edge)集合。
*   **分类**：
    *   **有向图** vs **无向图**。
    *   **完全图**：任意两个顶点间都有边（无向图 $n(n-1)/2$ 条边，有向图 $n(n-1)$ 条边）。
*   **度 (Degree)**：
    *   无向图：连接该顶点的边数。**总度数 = 2 $\times$ 边数**。
    *   有向图：**入度** (指向我) + **出度** (指出我)。
*   **连通性**：
    *   **连通图**（无向）：任意两个顶点都有路径相通。
    *   **强连通图**（有向）：任意两点 $v_i \to v_j$ 和 $v_j \to v_i$ 都有路径。
    *   **连通分量**：极大连通子图（图没连通的部分，切开来看每块都是连通的）。

**B. 图的存储结构（必考转换）**
1.  **邻接矩阵 (Adjacency Matrix)**：
    *   用二维数组 `A[n][n]` 存储。
    *   `A[i][j] = 1` (或权值) 表示有边，`0` (或 $\infty$) 表示无边。
    *   *特点*：
        *   判断两点是否有边：$O(1)$。
        *   找某个点的所有邻居：$O(n)$。
        *   **度计算**：
            *   无向图：第 $i$ 行（或列）之和。
            *   有向图：**第 $i$ 行之和 = 出度**；**第 $i$ 列之和 = 入度**。
2.  **邻接表 (Adjacency List)**：
    *   数组（存顶点）+ 链表（存邻居）。
    *   *特点*：节省空间（适合稀疏图）。
    *   **度计算**：
        *   有向图：顶点 $i$ 的链表长度是 **出度**。求入度需要遍历整个邻接表（麻烦），或者建立“逆邻接表”。

**C. 图的遍历**
1.  **深度优先搜索 (DFS)**：
    *   类似于树的**先序遍历**。
    *   一条路走到黑，撞墙了回退。
    *   **实现**：递归 或 栈。
    *   *结果*：生成“DFS 生成树”。
2.  **广度优先搜索 (BFS)**：
    *   类似于树的**层次遍历**。
    *   先访问所有邻居，再访问邻居的邻居。
    *   **实现**：**队列**。
    *   *结果*：生成“BFS 生成树”（这也是最短路径树，适用于无权图）。

**D. 四大核心算法（手算模拟必考）**
1.  **最小生成树 (MST)** —— 连通所有点，代价最小。
    *   **Prim 算法**：
        *   *策略*：从一个点出发，每次选**连接“已选集合”和“未选集合”的权值最小的边**，把对面的点拉进来。
        *   *复杂度*：$O(n^2)$，适合稠密图。
    *   **Kruskal 算法**（通常考 Prim 较多）：
        *   *策略*：每次选全局权值最小的边，只要不形成环就加入。
2.  **最短路径** —— 两点间距离最短。
    *   **Dijkstra 算法**（单源最短路）：
        *   *策略*：贪心。从起点开始，通过中转点不断刷新到其他点的距离。
        *   *核心数据结构*：`D[n]` 数组（存当前最短距离），`visited[]` 标记。
        *   *注意*：边权不能为负。
3.  **拓扑排序 (Topological Sort)**：
    *   *对象*：AOV 网（有向无环图 DAG）。
    *   *方法*：每次找一个**入度为 0** 的顶点输出，并**删除它及其发出的边**。重复直到空。
    *   *作用*：判断图是否有环（如果最后还有点剩下来，说明有环）。
4.  **关键路径**：
    *   *对象*：AOE 网（带权 DAG，边表示活动，点表示事件）。
    *   *核心*：**最长路径**（决定了整个工程的最短工期）。
    *   *计算*：最早开始时间 ($ve$) vs 最晚开始时间 ($vl$)。$ve = vl$ 的活动就是关键活动。

---

#### 2. 本章核心考点（必须掌握）

1.  **邻接矩阵 vs 邻接表**：
    *   选择题常考：给定一个图的边数和顶点数，问哪种存储更省空间？
    *   邻接矩阵 $O(n^2)$，邻接表 $O(n+e)$。
2.  **手动模拟算法（大题）**：
    *   给你一个带权图，画出 Prim 算法每一步选择了哪条边。
    *   给你一个带权图，填表写出 Dijkstra 算法每一步的 `D[]` 数组变化。
3.  **拓扑序列的唯一性**：
    *   一个图的拓扑序列**可能不唯一**（如果有多个入度为 0 的点，选谁都行）。
4.  **关键路径理解**：
    *   关键路径上的活动延误，整个工程必延误。
    *   非关键路径上的活动延误（在缓冲期内），不影响工期。

---

#### 3. 典型例题与解析

**例题 1：存储结构与度**
**题目**：在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（ ）倍。
**解析**：
*   每条边都有一个箭头，既贡献了一个出度（箭尾），也贡献了一个入度（箭头）。
*   所以：$\sum \text{入度} = \sum \text{出度} = \text{边数}$。
*   **答案**：1 倍。

**例题 2：最小生成树 (Prim)**
**题目**：给定顶点集 $V=\{1,2,3,4\}$，邻接矩阵如下，求从顶点 1 开始的 MST 边序列。
```
   1  2  3  4
1  ∞  2  4  ∞
2  2  ∞  1  5
3  4  1  ∞  3
4  ∞  5  3  ∞
```
**解析**：
*   **初始状态**：已选 $U=\{1\}$。候选边：$(1,2)=2, (1,3)=4$。
*   **第一步**：选最小边 **$(1,2)$**。加入 2。$U=\{1,2\}$。
    *   新候选边加入：$(2,3)=1, (2,4)=5$。
    *   当前所有跨界边：$(1,3)=4, (2,3)=1, (2,4)=5$。
*   **第二步**：选最小边 **$(2,3)$**。加入 3。$U=\{1,2,3\}$。
    *   新候选边加入：$(3,4)=3$。
    *   当前所有跨界边：$(1,3)=4$ (无效，3已在U), $(2,4)=5, (3,4)=3$。
*   **第三步**：选最小边 **$(3,4)$**。加入 4。$U=\{1,2,3,4\}$。
*   **MST 边集**：$\{(1,2), (2,3), (3,4)\}$。总权值 $2+1+3=6$。

**例题 3：最短路径 (Dijkstra)**
**题目**：上图中，求顶点 1 到其余各点的最短路径 $D[]$。
**解析**：
*   **Init**: $U=\{1\}$。$D[2]=2, D[3]=4, D[4]=\infty$。
*   **Round 1**:
    *   找 $D$ 中最小且未访问的：$D[2]=2$ 最小。选定 2。
    *   通过 2 更新邻居：
        *   到 3：$D[2] + \text{weight}(2,3) = 2 + 1 = 3$。原 $D[3]=4$。$3 < 4$，更新 **$D[3]=3$**。
        *   到 4：$D[2] + \text{weight}(2,4) = 2 + 5 = 7$。原 $D[4]=\infty$。更新 **$D[4]=7$**。
    *   当前 $D$: $[0, 2, 3, 7]$。
*   **Round 2**:
    *   找最小未选：$D[3]=3$。选定 3。
    *   通过 3 更新邻居：
        *   到 4：$D[3] + \text{weight}(3,4) = 3 + 3 = 6$。原 $D[4]=7$。$6 < 7$，更新 **$D[4]=6$**。
    *   当前 $D$: $[0, 2, 3, 6]$。
*   **Round 3**: 选定 4。无后续。
*   **答案**：$D[2]=2, D[3]=3, D[4]=6$。

**例题 4：拓扑排序**
**题目**：判断题：若一个有向图的邻接矩阵是三角矩阵（对角线以下全为 0），则该图必有拓扑序列。
**解析**：
*   如果是上三角矩阵，说明只有 $i \to j$ ($i < j$) 的边，没有回头路。
*   这意味着一定没有环。
*   有向无环图 (DAG) 一定存在拓扑序列。
*   **答案**：正确。

---


---

### 第八章：查找 (Search)

#### 1. 详细知识点讲解

**A. 静态查找表**
1.  **顺序查找 (Sequential Search)**：
    *   从头到尾挨个找。
    *   *哨兵技巧*：把待查元素放在下标 0 处，从后往前找，可以免去判断数组越界的步骤。
    *   ASL（成功）：$(n+1)/2$。
2.  **折半查找 (Binary Search) —— 重点**：
    *   **前提**：必须是**顺序存储**（数组），且必须**有序**。
    *   **过程**：`mid = (low + high) / 2`。比中间大去右边找，比中间小去左边找。
    *   **判定树**：折半查找的过程可以用一棵二叉树来描述。
        *   判定树一定是**平衡二叉树**。
        *   树中圆形结点代表“查找成功”，方形（空）结点代表“查找失败”。

**B. 动态查找表**
1.  **二叉排序树 (BST)**：
    *   **定义**：左子树所有点 < 根 < 右子树所有点。**中序遍历** BST 得到的是一个递增序列。
    *   **考点**：
        *   **插入/建树**：给一个无序序列，从空树开始，第一个元素是根，后面来的比根小放左边，比根大放右边（**不需要移动位置**，形状取决于输入顺序）。
        *   **删除**（难点）：
            *   删叶子：直接删。
            *   删只有一棵子树的点：子承父业。
            *   删有两个子树的点：找**左子树的最大值**（前驱）或**右子树的最小值**（后继）来顶替它，然后删掉那个替身。
2.  **平衡二叉树 (AVL)**：
    *   **定义**：任意结点的左、右子树深度之差（平衡因子）绝对值不超过 1。
    *   **目的**：防止 BST 退化成链表，保证查找效率为 $O(\log n)$。
    *   **调整**：LL, RR, LR, RL 四种旋转（重点理解概念，知道什么时候需要平衡化）。

**C. 哈希表 (Hash Table) —— 必考计算大题**
*   **哈希函数**：最常用 **除留余数法** $H(key) = key \% p$。
    *   $p$ 一般取小于等于表长的最大质数。
*   **处理冲突的方法**：
    1.  **开放定址法**：
        *   **线性探测**：$d_i = 1, 2, 3...$ （位置被占了？往后挨个找，到了表尾回表头）。
        *   **二次探测**：$d_i = 1^2, -1^2, 2^2, -2^2...$ （跳着找，减少聚集）。
    2.  **拉链法 (Chaining)**：
        *   数组里存指针，冲突的元素挂成一个链表。
        *   *优点*：没有堆积现象，删除容易。

**D. 评价指标：平均查找长度 (ASL)**
这是本章的**灵魂**，必须会算。
*   **$ASL_{成功}$**：$\sum$ (每个元素找到它所需的比较次数) / 元素个数。
*   **$ASL_{失败}$**：$\sum$ (每个查找失败的位置所需的比较次数) / 失败情况的个数。
    *   *注*：在哈希表中，失败通常指探测到了“空位置”或者链表末尾。

---

#### 2. 本章核心考点（必须掌握）

1.  **折半查找判定树与 ASL**：
    *   画出判定树，数每一层有几个结点。
    *   $ASL_{成功} = \frac{1 \times 1 + 2 \times 2 + 3 \times 4 + \dots}{n}$。
2.  **哈希表的构建与 ASL（重灾区）**：
    *   给定 keys，表长 $m$，哈希函数 $p$，冲突解决策略。
    *   **画出哈希表**（填格子）。
    *   **计算 ASL 成功**：注意线性探测时，不是比较 1 次，而是看它“跳”了几次才落座。
    *   **计算 ASL 失败**：对于 $0 \dots p-1$ 的每一个余数入口，算一下如果要查一个不存在的数，需要几次碰壁才能发现“空位”。
3.  **BST 的性质**：
    *   判断题：BST 的中序遍历有序？（是）。
    *   先序/后序能否确定 BST？（配合中序可以，单给一个序列如果隐含它是 BST 的构建序列也可以）。

---

#### 3. 典型例题与解析

**例题 1：折半查找 ASL**
**题目**：长度为 10 的有序表，进行折半查找。求 $ASL_{成功}$。
**解析**：
*   画判定树（或心算层数）：
    *   10 个结点。
    *   第 1 层：1 个 (mid)
    *   第 2 层：2 个
    *   第 3 层：4 个
    *   第 4 层：3 个 (1+2+4=7，还剩3个)
*   总比较次数 = $1\times1 + 2\times2 + 3\times4 + 4\times3 = 1 + 4 + 12 + 12 = 29$。
*   $ASL_{成功} = 29 / 10 = 2.9$。

**例题 2：哈希表构建与 ASL（线性探测法）**
**题目**：
关键字序列：{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}
表长 $m=16$，哈希函数 $H(key) = key \% 13$。
解决冲突：线性探测法。
求 $ASL_{成功}$。

**解析**：
1.  **填表过程**：
    *   19 % 13 = 6。放下标 6。(比较1次)
    *   14 % 13 = 1。放下标 1。(比较1次)
    *   23 % 13 = 10。放下标 10。(比较1次)
    *   1 % 13 = 1 (冲突！)。往后找 -> 2 空。放下标 2。(比较2次：1->2)
    *   68 % 13 = 3。放下标 3。(比较1次)
    *   20 % 13 = 7。放下标 7。(比较1次)
    *   84 % 13 = 6 (冲突！)。往后找 -> 7(占) -> 8(空)。放下标 8。(比较3次：6->7->8)
    *   27 % 13 = 1 (冲突！)。1(占)->2(占)->3(占)->4(空)。放 4。(比较4次)
    *   55 % 13 = 3 (冲突！)。3->4->5(空)。放 5。(比较3次)
    *   11 % 13 = 11。放 11。(比较1次)
    *   10 % 13 = 10 (冲突！)。10->11->12(空)。放 12。(比较3次)
    *   79 % 13 = 1 (冲突！)。1->...->5->? (这里要一直往后找) -> ... -> 9(空)。放 9。(比较9次：1,2,3,4,5,6,7,8,9)。
2.  **计算**：
    *   总比较次数 = $1+1+1+2+1+1+3+4+3+1+3+9 = 30$。
    *   $ASL = 30 / 12 = 2.5$。
*   *提示*：一定要细心数“冲突了几次”，包括最后找到空位的那一次比较也算。

**例题 3：哈希表 ASL 失败（难点）**
**题目**：接上题，求 $ASL_{失败}$。
**解析**：
*   分母是哈希函数取值的个数（即 $p=13$），不是表长 16，也不是元素个数 12。我们假设查询的 key 可能映射到 0~12 任意位置。
*   **计算**：看每个入口位置 $i (0 \dots 12)$，往后数几个才遇到**空位**（因为遇到空位才确定查不到）。
    *   位置 0: 空。比较 1 次。
    *   位置 1: 非空...一直连到位置 12 都是满的？不，看表分布：
        *   下标：0(空), 1(有), 2(有), 3(有), 4(有), 5(有), 6(有), 7(有), 8(有), 9(有), 10(有), 11(有), 12(有), 13(空)。
    *   $H(key)=0$: 查下标0，空。1次。
    *   $H(key)=1$: 查1(非空)..一直走到13(空)。共13步。
    *   $H(key)=2$: 查2..走到13。共12步。
    *   ...
    *   $H(key)=6$: 查6..走到13。共8步。
    *   ...
    *   $H(key)=12$: 查12(非空)->13(空)。共2步。
*   将所有步数相加，除以 13。

---


---

### 第九章：排序 (Sorting)

#### 1. 详细知识点讲解

**A. 插入排序类**
1.  **直接插入排序**：
    *   *逻辑*：摸牌。手里已经有一把排好的牌，新摸一张，插到合适的位置。
    *   *特点*：**稳定**。适合**基本有序**的序列（最快 $O(n)$）。
2.  **希尔排序 (Shell Sort)**：
    *   *逻辑*：缩小增量排序。先按 $d_1$ 分组插排，再按 $d_2$ 分组插排...直到 $d=1$。
    *   *特点*：**不稳定**。目的是为了打破逆序，让数据跳跃式移动。

**B. 交换排序类**
1.  **冒泡排序 (Bubble Sort)**：
    *   *逻辑*：两两比较，大的往后冒。一趟下来，最大的元素“沉底”（到了最后）。
    *   *特点*：**稳定**。若一趟下来没有发生交换，可提前结束（优化点）。
2.  **快速排序 (Quick Sort) —— 必考之王**：
    *   *逻辑*：分治法。
        *   选一个**枢轴 (Pivot)**（通常是第一个元素）。
        *   **Partition (划分)**：把比它小的都扔左边，比它大的都扔右边。
        *   递归处理左右两边。
    *   *特点*：**不稳定**。
    *   *地位*：**所有同数量级排序中，平均性能最好**（这也是为什么 C++ STL `sort` 默认用它）。
    *   *最坏情况*：序列本来就有序（正序或逆序），退化成冒泡 $O(n^2)$。

**C. 选择排序类**
1.  **简单选择排序**：
    *   *逻辑*：每次从后面待排序列中选一个最小的，交换到前面。
    *   *特点*：**不稳定**（比如 `2  2* 1`，1和第一个2换位，`2*` 就跑到 `2` 前面了）。比较次数与序列初始状态无关（永远是 $O(n^2)$）。
2.  **堆排序 (Heap Sort) —— 难点**：
    *   *逻辑*：
        *   把数组看作**完全二叉树**。
        *   **建堆**：从最后一个非叶子结点 ($\lfloor n/2 \rfloor$) 开始，从下往上，配合**下坠 (Sift Down)** 调整，建成大顶堆（或小顶堆）。
        *   **排序**：把堆顶（最大值）和堆底（最后一个）交换，然后把剩下的 $n-1$ 个元素重新调整为堆。
    *   *特点*：**不稳定**。时间复杂度恒定 $O(n \log n)$。空间复杂度 $O(1)$（不需要额外数组）。

**D. 归并排序 (Merge Sort)**
*   *逻辑*：分治。先把左边排好，再把右边排好，最后把两个有序数组**合并**成一个。
*   *特点*：**稳定**。时间 $O(n \log n)$。但是**空间复杂度高** $O(n)$（需要一个辅助数组）。

---

#### 2. 本章核心考点（必须掌握）

**A. 排序算法复杂度八股文（必背表格）**

这是**送分题**，也是**送命题**，背错一个可能连错好几道。

| 排序算法 | 平均时间 | 最好时间 | 最坏时间 | 空间复杂度 | 稳定性 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **直接插入** | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | **稳定** |
| **希尔** | $O(n^{1.3})$ | - | $O(n^2)$ | $O(1)$ | **不稳定** |
| **冒泡** | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | **稳定** |
| **快速** | **$O(n \log n)$** | $O(n \log n)$ | **$O(n^2)$** | **$O(\log n)$** | **不稳定** |
| **简单选择** | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | **不稳定** |
| **堆排序** | **$O(n \log n)$** | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | **不稳定** |
| **归并** | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | **$O(n)$** | **稳定** |

*   **助记口诀**：
    *   **不稳定**的：**“快 希 选 堆”**（快些选一堆朋友去玩 -> 既然玩得快，关系就不稳定）。
    *   **时间复杂度 $O(n \log n)$** 的：**“快 归 堆”**。
    *   **空间复杂度**：只有**快排**（递归栈 $\log n$）和**归并**（辅助数组 $n$）需要额外空间，其他都是 $O(1)$。

**B. 手工模拟（大题）**
1.  **快速排序的 Partition**：
    *   给你一个数组，问**一趟排序**后的结果。
    *   *方法*：左右指针法（交替填坑法）。
2.  **堆的建立与调整**：
    *   给你一个数组，画出初始的大顶堆。
    *   *方法*：从下往上找“三角关系”，大的上去，小的下来。注意下来的小的如果破坏了下面的堆，要继续往下沉。

---

#### 3. 典型例题与解析

**例题 1：快速排序 Partition**
**题目**：对序列 `{46, 79, 56, 38, 40, 84}` 进行快速排序，以第一个元素为枢轴，写出一趟排序后的结果。
**解析**：
*   Pivot = 46。指针 Low 指向 46 (空坑)，High 指向 84。
1.  **High 走**：找比 46 小的。
    *   84 > 46，High--。
    *   40 < 46，**停**。把 40 填到 Low 的坑。序列变 `{40, 79, 56, 38, [空], 84}`。Low++。
2.  **Low 走**：找比 46 大的。
    *   79 > 46，**停**。把 79 填到 High 的坑。序列变 `{40, [空], 56, 38, 79, 84}`。High--。
3.  **High 走**：
    *   38 < 46，**停**。把 38 填到 Low 的坑。序列变 `{40, 38, 56, [空], 79, 84}`。Low++。
4.  **Low 走**：
    *   56 > 46，**停**。把 56 填到 High 的坑。序列变 `{40, 38, [空], 56, 79, 84}`。High--。
5.  **相遇**：Low 和 High 撞在第 3 个位置（下标 2）。把 Pivot (46) 填进去。
*   **结果**：`{40, 38, 46, 56, 79, 84}`。
*   *检查*：46 左边全比它小，右边全比它大。正确。

**例题 2：堆排序（建堆）**
**题目**：序列 `{5, 3, 17, 10, 84, 19, 6, 22, 9}`，建大顶堆。
**解析**：
*   逻辑结构是完全二叉树。
*   最后一个非叶子结点：下标 $\lfloor 9/2 \rfloor = 4$（元素 10）。
*   **调整步骤**：
    1.  调整 10：子节点 22, 9。22最大。交换 10 和 22。
    2.  调整 17（下标3）：子节点 19, 6。19最大。交换 17 和 19。
    3.  调整 3（下标2）：子节点 22(变了), 84。84最大。交换 3 和 84。
    4.  调整 5（根）：子节点 84, 19。84最大。交换 5 和 84。
        *   **下沉**：5 下来后，看子节点。3, 22。22最大。交换 5 和 22。
        *   **再下沉**：5 下来后，看子节点。10, 9。10最大。交换 5 和 10。
*   *考点*：重点在于根节点下来的那个 5，要一路沉到底，不能只换一次。

**例题 3：算法选择**
**题目**：若数据元素序列原本就是**基本有序**的，选择哪种排序算法效率最高？
A. 冒泡排序
B. 快速排序
C. 直接插入排序
D. 选择排序
**解析**：
*   **直接插入排序**在基本有序时，几乎不用移动，接近 $O(n)$。
*   **冒泡排序**在改进后（加 flag）也是 $O(n)$，但通常认为插入更好。
*   **快速排序**在有序时最惨，退化成 $O(n^2)$。
*   **答案**：C。

---

### 全书复习总结与机试策略

**至此，九章内容全部复习完毕。** 根据你的资料，最后给你一些针对性的建议：

1.  **机试策略 (30分)**：
    *   **4 选 2**：一定要先浏览这 4 道题。
    *   **优先选**：
        *   **线性表/栈/队列**（通常是模拟题，逻辑简单）。
        *   **二叉树遍历**（递归很好写）。
        *   **简单的查找/排序**（直接调库函数 `qsort` 或 `std::sort` 甚至都不用手写快排，除非强制要求）。
    *   **慎选**：复杂的图算法（代码量大，容易 DeBug 很久）。
2.  **拿分技巧**：
    *   做对 2 题拿满基础分 30 分。做对更多有加分。
    *   **求稳**：先确保 2 题 100% 正确（测试边界条件，比如空表、由1个元素组成的表）。

