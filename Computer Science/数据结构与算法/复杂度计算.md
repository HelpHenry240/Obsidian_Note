
**复杂度分析看的是：随着输入数据量 $n$ 的增大，算法执行时间和空间占用的“增长趋势”。**

---

### 第一部分：怎么计算时间复杂度？

时间复杂度通常用 **大O符号 (Big O Notation)** 表示，关注的是**最坏情况**下的**最高阶项**。

#### 1. 计算的三大原则
1.  **只看最高阶**：如果计算结果是 $3n^2 + 10n + 1000$，只保留 $n^2$。因为当 $n$ 无穷大时，其他项微不足道。
2.  **忽略系数**：$O(2n)$ 约等于 $O(n)$。
3.  **加法 vs 乘法**：
    *   代码是并列的（循环A之后循环B） $\rightarrow$ 加法（取最大值）。
    *   代码是嵌套的（循环A里套循环B） $\rightarrow$ 乘法。

#### 2. 常见代码模式速查

*   **$O(1)$ 常数阶**：
    没有循环，没有递归，代码行数固定。
    ```java
    int a = 10;
    int b = 20;
    int c = a + b; // 无论数据多大，只执行一次
    ```

*   **$O(n)$ 线性阶**：
    一层循环，或者递归深度为 $n$。
    ```java
    for (int i = 0; i < n; i++) {
        print(i); 
    }
    ```

*   **$O(\log n)$ 对数阶**：
    循环变量翻倍或减半（二分法核心）。
    ```java
    // 每次 i 乘以 2，距离 n 越来越近
    for (int i = 1; i < n; i = i * 2) {
        print(i);
    }
    ```

*   **$O(n \log n)$ 线性对数阶**：
    $O(\log n)$ 的循环外面套了一层 $O(n)$。常见于归并排序、快速排序。

*   **$O(n^2)$ 平方阶**：
    双重嵌套循环。
    ```java
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            print(i + j);
        }
    }
    ```

*   **$O(2^n)$ 指数阶**：
    通常出现在递归求解子问题（如斐波那契数列的暴力递归）。**这是性能杀手，必须优化。**

---

### 第二部分：怎么计算空间复杂度？

空间复杂度 $S(n)$ 看的是**除了输入数据本身之外，算法额外申请了多少内存空间**。

#### 1. 变量与数组
*   **$O(1)$**：只声明了常数个变量（`i`, `j`, `temp`），与 $n$ 大小无关。
*   **$O(n)$**：申请了一个长度为 $n$ 的数组或列表。
*   **$O(n^2)$**：申请了一个 $n \times n$ 的二维数组（矩阵）。

#### 2. 递归栈空间（最容易被忽略！）
递归函数在调用时，操作系统会把每层调用的参数压入栈中。
**空间复杂度 = 递归树的深度**。

```java
// 递归计算阶乘
// 递归深度是 n，所以空间复杂度是 O(n)
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

---

### 第三部分：常见数据结构复杂度总表

**图例说明**：
*   绿色：非常快
*   黄色：一般
*   红色：较慢

| 数据结构 | 访问 (Access) | 查找 (Search) | 插入 (Insertion) | 删除 (Deletion) | 备注 (Trade-off) |
| :--- | :---: | :---: | :---: | :---: | :--- |
| **数组 (Array)** | $O(1)$ | $O(n)$ | $O(n)$ | $O(n)$ | 读快写慢，连续内存 |
| **链表 (Linked List)** | $O(n)$ | $O(n)$ | $O(1)$* | $O(1)$* | 读慢写快，*需已知位置 |
| **栈 (Stack)** | - | $O(n)$ | $O(1)$ | $O(1)$ | 只能操作栈顶 |
| **队列 (Queue)** | - | $O(n)$ | $O(1)$ | $O(1)$ | 队尾进，队头出 |
| **哈希表 (Hash Table)** | N/A | $O(1)$ | $O(1)$ | $O(1)$ | **平均情况**，最坏会退化为$O(n)$ |
| **二叉搜索树 (BST)** | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | **平衡状态**，不平衡则退化为$O(n)$ |
| **AVL树 / 红黑树** | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | $O(\log n)$ | 严格保证平衡 |
| **堆 (Heap)** | $O(1)$(堆顶) | $O(n)$ | $O(\log n)$ | $O(\log n)$ | 找最大/最小值神器 |

> **注意**：
> 1. 链表的插入/删除说是 $O(1)$，前提是你已经拿到了要操作节点的指针。如果需要先查找再删除，总耗时是 $O(n)$。
> 2. 哈希表看似无敌，但如果哈希冲突严重（Hash Collisions），性能会急剧下降。

---

### 第四部分：常见排序算法复杂度总表

排序算法是算法复杂度的最佳练兵场。

| 算法名称 | 最好时间 | **平均时间** (重点) | 最坏时间 | **空间复杂度** | 稳定性 | 适用场景 |
| :--- | :---: | :---: | :---: | :---: | :---: | :--- |
| **冒泡排序** | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 | 教学用，实际很少用 |
| **选择排序** | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 | 数据移动少 |
| **插入排序** | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 | **小数据量 ($n < 50$) 极快** |
| **归并排序** | $O(n \log n)$ | **$O(n \log n)$** | $O(n \log n)$ | $O(n)$ | 稳定 | 外部排序，由于占空间大，内存中不如快排 |
| **快速排序** | $O(n \log n)$ | **$O(n \log n)$** | $O(n^2)$ | $O(\log n)$ | 不稳定 | **工业界首选** (综合性能最强) |
| **堆排序** | $O(n \log n)$ | **$O(n \log n)$** | $O(n \log n)$ | $O(1)$ | 不稳定 | 空间受限时的优选 |

---

### 总结：如何一眼看穿复杂度？

当你看到一段代码时，遵循以下直觉：

1.  **二分查找/倍增** $\rightarrow$ 立刻想到 $O(\log n)$。
2.  **遍历数组/链表** $\rightarrow$ 立刻想到 $O(n)$。
3.  **排序** $\rightarrow$ 通常是 $O(n \log n)$。
4.  **穷举所有组合/子集** $\rightarrow$ 指数级 $O(2^n)$，警惕超时。
5.  **空间换时间** $\rightarrow$ 用哈希表记录中间结果，空间 $O(n)$，把时间从 $O(n^2)$ 降到 $O(n)$。

