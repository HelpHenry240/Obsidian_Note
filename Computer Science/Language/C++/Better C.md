这一阶段主要被称为 **"Better C"** 阶段。也就是在不使用复杂的面向对象（类）和泛型（模板）特性的情况下，C++ 如何作为一种“更安全、更高效、更方便的 C 语言”存在。

很多 C++ 教程一开始就讲类和对象，往往会让人忽视这些基础语法的改进，而这些改进恰恰是写出高质量 C++ 代码的前提。

以下从 **7个维度** 详细展开 C++ 基础阶段与 C 语言的深度对比：

---

### 1. 输入与输出 (I/O)
C++ 的 I/O 库设计理念是“类型安全”和“可扩展性”，这与 C 的“格式化控制”有很大不同。

| 特性       | **C 语言 (`stdio.h`)**                                    | **C++ (`iostream`)**                                                 |
| :------- | :------------------------------------------------------ | :------------------------------------------------------------------- |
| **核心函数** | `printf`, `scanf`                                       | `std::cout`, `std::cin`                                              |
| **类型安全** | **不安全**。如果用 `%d` 打印 `double`，或者 `%s` 对应错误的内存，程序可能崩溃或乱码。 | **安全**。编译器**自动识别变量类型**，调用对应的重载函数。                                    |
| **扩展性**  | 很难扩展支持自定义结构体。                                           | 极其容易。只需重载 `<<` 和 `>>` 运算符，自定义类型也能像 `int` 一样打印。                       |
| **性能**   | 极快。                                                     | 默认比 C 慢（因为要同步 C 的缓冲区），但执行 `std::ios::sync_with_stdio(false);` 后速度相当。 |

**代码对比：**

```c
// C 语言
int a = 10;
char s[] = "hello";
printf("Num: %d, Str: %s\n", a, s); // 必须手动匹配 %d 和 %s
```

```cpp
// C++
int a = 10;
std::string s = "hello";
std::cout << "Num: " << a << " Str: " << s << std::endl; // 自动推导类型
```

---

### 2. 变量与数据类型 (Variables & Types)
[[]]
C++ 引入了更严格的类型检查和更方便的类型推导。

*   **布尔类型 (`bool`)**：
    *   **C**: C99之前没有原生布尔，通常用 `int` (0/1) 或宏。
    *   **C++**: 原生关键字 `bool`，取值 `true` / `false`。
*   **变量声明位置**：
    *   **C (旧标准)**: 必须在作用域（函数）开头声明所有变量。
    *   **C++**: **随用随定义**。这非常重要，可以减小变量作用域，防止误用，提高性能（避免不必要的初始化）。
*   **自动类型推导 (`auto`)** (C++11)：
    *   **C**: 必须显式写出类型，如 `unsigned long long`。
    *   **C++**: `auto i = 10;` 编译器自动推导出 `int`。在处理复杂类型（如迭代器）时是神器。

---

### 3. 指针 vs 引用 (Pointer vs Reference) —— **核心重点**
[指针和引用](指针和引用.md)
这是 C++ 基础阶段最重要的概念变化。**引用**是 C++ 为了解决指针代码晦涩、不安全而引入的特性。

| 特性 | **指针 (`*`)** | **引用 (`&`)** |
| :--- | :--- | :--- |
| **本质** | 存放内存地址的变量。 | 变量的**别名** (Alias)。 |
| **空值** | 可以是 `NULL` / `nullptr`。 | **必须在定义时初始化，且不能为“空”**。 |
| **重指向** | 可以随时指向别的变量。 | 一旦绑定，**终身不换**。 |
| **语法** | 需要解引用 (`*p`)，访问成员用 `->`。 | 像普通变量一样使用，访问成员用 `.`。 |
| **用途** | 处理数组、底层内存操作、可选参数。 | 函数参数传递、返回值优化（减少拷贝）。 |

**代码对比（函数参数修改）：**

```c
// C 语言：必须传地址，函数内部要解引用
void swap(int *a, int *b) {
    if (a != NULL && b != NULL) { // 需要判空
        int temp = *a;
        *a = *b;
        *b = temp;
    }
}
// 调用：swap(&x, &y);
```

```cpp
// C++：使用引用，代码极其干净
void swap(int &a, int &b) { // 也就是 a 是 x 的别名
    int temp = a;
    a = b;
    b = temp;
}
// 调用：swap(x, y); -> 看起来像传值，实际是传引用
```

---

### 4. 字符串处理 (String Handling)
[字符串处理](字符串处理.md)
这是 C++ 新手感到最幸福的地方。

*   **C 语言 (`char*` / `char[]`)**：
    *   本质是**以空字符 `\0` 结尾的字符数组**。
    *   **极度危险**：容易发生缓冲区溢出（Buffer Overflow）。
    *   操作繁琐：赋值用 `strcpy`，拼接用 `strcat`，比较用 `strcmp`，求长度用 `strlen`。
    *   内存管理：如果字符串长度变化，需要手动 `malloc`/`realloc`。

*   **C++ (`std::string`)**：
    *   本质是一个**类**，封装了 `char*`，自动管理内存。
    *   **安全**：越界检查（如果用 `at()`），自动扩容。
    *   操作直观：赋值 `=`，拼接 `+`，比较 `==` / `<`。

**代码对比：**

```c
// C 语言：拼接字符串
char str1[20] = "Hello";
char str2[] = " World";
strcat(str1, str2); // 如果 str1 空间不足20，这里直接内存越界导致崩溃
```

```cpp
// C++
std::string str1 = "Hello";
std::string str2 = " World";
str1 = str1 + str2; // 自动申请内存，永远不用担心空间不够
```

---

### 5. 内存管理基础 (Memory Management)
虽然 C++ 也支持 `malloc`/`free`，但强烈不建议使用。

| 特性 | **C (`malloc` / `free`)** | **C++ (`new` / `delete`)** |
| :--- | :--- | :--- |
| **性质** | 库函数 (Library Functions)。 | **运算符 (Operators)**。 |
| **类型安全** | 返回 `void*`，必须强转类型。 | 自动返回对应类型的指针，无需强转。 |
| **大小计算** | 手动计算字节数 `sizeof(int) * 10`。 | 编译器自动计算。 |
| **初始化** | **不调用构造函数**（仅分配内存）。 | **自动调用构造函数**（分配内存 + 初始化）。 |
| **销毁** | **不调用析构函数**。 | **自动调用析构函数**（清理资源 + 释放内存）。 |

**重要结论**：在 C++ 中，**对象**的生命周期至关重要，`malloc` 无法处理对象的初始化逻辑，所以必须用 `new`（在现代 C++ 中，更进一步建议用 `std::make_unique` 连 `new` 都省了）。

---

### 6. 函数的增强 (Function Enhancements)
C++ 对函数做了很多扩展，让代码更灵活。

1.  **函数重载 (Overloading)**：
    *   **C**: 函数名必须唯一。`print_int`, `print_float`。
    *   **C++**: 允许同名函数，**只要参数列表（类型或数量）不同。编译器通过“名字修饰” (Name Mangling) 来区分。**
2.  **默认参数 (Default Arguments)**：
    *   **C**: 不支持。
    *   **C++**: `void func(int a, int b = 10);` 调用时可以只传 `func(5)`。
3.  **内联函数 (Inline Functions)**：
    *   **C**: 使用宏函数 `#define MAX(a,b) ((a)>(b)?(a):(b))`，没有类型检查，容易产生副作用（比如 `a++`）。
    *   **C++**: 使用 `inline` 关键字。既有宏的高效（由编译器展开，无函数调用开销），又有函数的类型安全。

---

### 7. 命名空间 (Namespace)
这是为了解决大型项目中**命名冲突**的问题。

*   **C**: 所有的全局变量、函数都在同一个全局作用域里。如果你的库有个函数叫 `init()`，别人的库也有个 `init()`，链接时就会报错。解决办法通常是加丑陋的前缀：`MyLib_init()`, `OpenGL_init()`。
*   **C++**: 引入 `namespace`。
    ```cpp
    namespace Physics {
        int calculate() { return 1; }
    }
    namespace Math {
        int calculate() { return 2; }
    }
    // 调用
    Physics::calculate();
    Math::calculate();
    ```

---

### 总结：如何完成思维转换？

在学习第一阶段时，你要时刻提醒自己：

1.  **忘掉 `char*`**，除非你要和底层 C 接口交互，否则一律用 `std::string`。
2.  **忘掉 `#define` 宏**，用 `const` 定义常量，用 `inline` 定义短函数。
3.  **忘掉 `malloc`**，用 `new`，或者直接用栈上的变量。
4.  **少用指针**，参数传递优先考虑 **引用 (`&`)** 或 **常量引用 (`const T&`)**。

